## 第1章 数据库系统概述

#### 课程研究的问题

* 数据如何组织并存储到数据库（数据组织）
  * 数据库体系结构
  * 数据模型
  * 数据库设计

* 应用如何访问数据库中的数据（数据存取）
  * SQL和PL/SQL
  * 数据库应用编程

* 如何保证数据的一致性、安全性和存取效率（数据管理）
  * 事务管理
  * 恢复、并发控制、完整性、安全性
  * 索引、查询优化

#### 数据库系统的基本概念

* 数据：与其语义不可分
* 数据库：数据库(Database,简称DB)是长期储存在计算机内、 有组织的、 可共享的大量数据的集合  
* 数据库模式：数据库模式是数据库中全体数据的逻辑结构和特征的描述  
* 数据库管理系统：DBMS，是计算机程序的集合，用于创建和维护数据库  （位于OS和用户应用之间）
* 数据库系统：DBS，指在计算机系统中引入了数据库后的系统，即采用了数据库技术的计算机系统  

#### 为何使用数据库

* 数据共享；减少冗余；避免不一致；提供事务支持：如银行转帐（原子性、一致性、隔离性、持久性）
  保持完整性；增强安全性；提供并发控制；标准化  

#### DBMS的功能

* 数据库定义：

  * 数据库对象定义：表、索引、约束、用户等  

* 数据库操纵

  * 实现对数据库的基本操作：增、删、改、查  

* 数据库保护

  * 恢复、并发控制、完整性控制、安全性控制  

* 数据库的建立和维护

  * 初始数据的转换和装入、数据备份、数据库的重组织、性能监控和分析等

    通常由一些实用程序完成  

#### DBMS的分类

* 按数据模型
  * 网状型、层次型
  * 关系型
  * 对象
  * NoSQL
* 按所支持的用户数
  * 单用户DBMS
  * 多用户DBMS
* 按允许数据库可以分布的站点数
  * 集中式DBMS
  * 分布式DBMS
* 按用途
  * 通用DBMS
  * 专用DBMS

#### DBMS的架构

#### 数据库技术的发展

* 人工管理阶段
* 文件系统阶段
* 数据库系统阶段

## 第2章 数据库系统体系结构

* DBMS：数据库管理系统

##### 数据库系统体系结构

* DBMS角度看

  数据库系统内部的模式结构

  * ANSI/SPARC体系结构（三级模式结构+两级映像）

  * 数据库模式的概念
    * 类型和值
    
    * 模式和实例
    
      * 模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及类型的描述，不涉及具体的值
      * 模式的一个具体值称为模式的一个实例  
      * 一个模式可有很多实例
        模式——反映数据的结构及联系
        实例——反映的是某一时刻数据库的状态
      * 模式相对稳定，而实例相对变动  
    
    * 数据库的3级模式结构：外模式、概念模式、内模式
    
      外模式是单个用户的视图，概念模式是所有用户的公共数据视图，内模式是数据库内部的存储视图  
    
    * 概念模式(模式、逻辑模式)：数据库中全体数据的逻辑结构和特征的描述，通过模式DDL进行定义
    
      一个数据库仅一个概念模式
    
    * 外模式(子模式、用户模式)：单个用户看到的局部数据的逻辑结构和特征的描述。通过外模式DDL定义
    
    * 内模式(存储模式)：数据物理结构和存储方式的描述(如记录按顺序存储、B树、还是散列存储；或者索引的组织、数据加密、压缩等)。 不涉及物理块/页的大小，也不考虑具体设备的柱面或磁道大小
    
      通过内模式DDL定义

  * 二级映像和数据独立性

    * 二级映像实现三级模式结构间的联系和转换

      * 外模式/模式映像：定义外模式与概念模式间的对应关系：

        * 属性名称可能不同
        * 外模式的属性可能由模式中的多个属性运算而得  
      
        数据的逻辑独立性
      
      * 模式/内模式映像：定义了概念模式与内模式间的对应关系
      
        数据的物理独立性

* 从数据库系统的最终用户角度看

  数据库系统的外部体系结构
  * 客户机/服务器结构：C/S
    * server专门用于执行DBMS功能，为数据库服务器
    * client安装DBMS外围应用开发工具、用户的应用系统
    * 优缺点
  * 浏览器/服务器机构：B/S
    * 服务器包括Web服务器和数据库服务器
    * 优缺点
  * 分布式结构
    * 局部应用和全局应用
    * 优缺点

## 第3章 关系数据模型

#### 数据模型的概念

* 数据模型是对现实世界数据特征的抽象
* 数据模型的定义：描述现实世界实体、实体间联系以及数据语义和一致性约束的模型
* 数据模型的分类（按模型应用的不同目的）
  * 概念数据模型（概念模型）：用户观点、强调语义表达
  * 结构数据模型（数据模型）：计算机系统的观点、面向数据库的逻辑结构，有严格的形式化定义
* 数据模型的三要素
  * 数据结构：现实世界实体及实体间联系的表示和实现  
  * 数据操作：数据检索和更新的实现  
  * 数据的完整性约束：数据及数据间联系应具有的制约和依赖规则  

#### 关系数据模型的概念

* 关系模型：二维表格表示实体集、外码表示实体间联系、三类完整性规则表示数据约束的数据模型
  * 属性（表的每一列为一个属性，列数称为度）
  * 关系模式：二维表格的表头
  * 元组(与实体对应，表格的每一行为一个元组，元组数目称为势或基数)
  * 域（一组具有相同数据类型的值的集合，每个属性有一个域，即取值范围）
  * 关系（元组的集合）
  * 属性值
  * 关系数据库模式：关系模式的集合
  * 关系数据库：关系数据库模式的实例（关系的集合）

#### 关系模式的形式化定义：R(U,D,dom,F)

* 码
  * 超码：在关系模式中能唯一标识一个元组的属性集称为关系模式的超码  
  * 候选码(无多余属性的超码；主属性，非主属性)
  * 主码(替换码)
* 关系的性质：
  * 属性值不可分解(属性值不能是集合)；
  * 元组不可重复；
  * 无行序、列序

* **关系数据模型的形式化定义**
  * 数据结构：关系
  * 数据操作：关系运算（关系代数、关系演算）
  * 数据的完整性约束：关系模型的三类完整性约束

#### 关系模型的三类完整性规则

* 实体完整性：关系模式的主码不可为空(主码里每一个属性均不为空)
* 参照完整性：外码（描述实体与实体间联系）。对应另一个关系模式的候选码
* 用户自定义完整性：针对某一具体数据的约束条件，反映某一具体应用所涉及的数据必须满足的特殊语义

#### 关系代数

* 原始的关系代数

  * 传统集合操作：并、交、差、积  （计算结果会去重）
  * 专门的关系操作：
    * 选择 ：$\sigma$， 算术表达式可以是属性名、常量、简单函数间的比较
    * 投影: $\pi$
    * 连接：
      * 自然连接：相当于在R× S中选取R和S的所有公共属性值都相等的元组，并在结果中去掉重复属性  
      * $\theta 连接$
      * 等值连接
    * ==除==
    * 补充：重命名操作: $\rho$ ，ppt45

* 附加的关系代数

  * 扩展投影（广义投影) ： ->
  * 聚集函数:SUM,COUNT,AVG,MAX,MIN
  * 分组
  * 排序
  * 赋值:<-

* 关系代数的封闭性、关系代数操作的可嵌套性

* 原始关系代数的基本运算：并、差、积、选择、投影 ； （重命名）

  其余的 交、连接、除 都可用基本运算来表示

* 关系代数表达式的定义

* 数据更新：通过关系代数实现

  * 删除
  * 插入
  * 修改





## 第4章 关系数据库语言SQL

#### 数据库语言

* 用户需要存取三类数据
  * 数据库的存取
  * 数据库模式的存取
  * 数据库访问控制信息的存取（授权、撤销）
* 用户与数据库的唯一接口：数据库语言
* 数据库语言包括3类子语言
  * 数据定义语言DDL：存取数据库模式
  * 数据操纵语言DML：存取数据库数据
  * 数据库控制语言DCL：存取访问控制信息

#### SQL概述

* SQL的发展历程

* SQL数据库中的术语

  * 基本表、表结构、记录、字段(列)、字段值、字段类型(列类型)、键、主键、外键

    以及与模型层面的术语的一一对应（ppt10）

* SQL数据库的三级体系结构

  * ppt 11 
  * 文件-基本表-视图

* SQL的组成（**ppt12**）

  * DDL：定义基本表、视图操作、索引操作
  * DML：记录操作
  * DCL：权限管理
  * 嵌入式SQL

#### SQL DDL

* 基本表的结构

  * 表名

  * 列：列类型: Char(n)（定长）、Varchar(n)（变长）、Int/Decimal、Date/Time

    常用列类型：ppt16

  * 完整性约束(如主键的选择)

    列约束与表约束：以下约束既可以定义在列上，也可以定义在基本表上

    * 主键约束：主码，实体完整性
    * 唯一键约束：候选码
    * 外键约束：外码，参照完整性
    * 检查约束：用户自定义完整性

* **创建基本表**：Create Table，表名、列和约束 （SQL数据库里表不一定必须有主键定义）

  * 定义列：列名、列类型、Default、NOT NULL、列约束
    * 默认值
  * 约束：列约束和表约束都可以有四种约束类型: 见上方笔记
    * 列约束：也可以有约束名；可以有多个约束子句
    * 表约束：定义多个列上的约束；可以有多个约束子句
    * 主键约束: 不许有空值，也不可重复
    * 唯一性约束: 值不可重复，但可以为空；且若约束列中有一列不为空，则实施约束；约束列都为空则不实施约束
    * 外键约束：表中某列值引用其他表的主键列或Unique列
      * 参照表（子表） 、被参照表（主表）
      * 一些错误示例：ppt30
      * 级联删除
      * 级联设空
    * Check约束：只能对每个元组做简单约束 （ppt31）

* 修改基本表: Alter Table

  * 增加列 Add
  * 删除列 Drop Column
  * 修改列：不能改列名， Modify
  * 重命名列：Rename column <old> To <new>
  * 增加约束：只能增加表约束 Add
  * 删除约束：约束定义时一定要有名字才行, Drop
  * 重命名表: Rename To 

* 删除基本表: Drop Table

  * 有 级联删除：把该表的所有约束同时删去

#### SQL DML

* 插入记录Insert
  * 可以指定或不指定列名
  * 列名未出现在列表中，则插入记录时以默认值填充，没有默认值则设为空
  * 日期数据的插入：注意格式
* 修改记录Update
  * Set+Where
* 删除记录Delete：一般根据主码，且是一条一条的删
* 查询记录Select
  * Select查询结构
    * Select 、 From、Where、Group By、Having、Order By
  * Select基本查询
    * 查询全部记录：*
    * 查询特定的列（投影操作）
    * 使用别名：别名包含空格，则须使用双引号
    * 使用表达式：字符串表达式、算术表达式、函数表达式
    * 检索特定的记录：Where（关系运算符包括：算术比较、IN、IS NULL/ IS NOT NULL、LIKE、EXISTS； 多个比较式可用NOT、AND和OR连接）
    * 去除重复记录：Distinct,只对记录有效，不针对某个特定列  
    * 排序查询结果(Order By)：ASC为升序，DESC为降序，默认升序
    * 使用聚集函数：Count、sum、avg、min、max
    * 聚集函数和分组操作(Group By)：分组属性可以有NULL，此时NULL单独为一组
    * 返回满足特定条件的分组结果(Having)：必须和Group By连用，且Having的条件一定与聚集函数有关
  * 连接查询
    * 一个查询从两个表中联合数据：连接条件Where的个数等于连接的表数-1
    * 两个表里有相同列名，需用表名做前缀
    * 使用表别名
    * 连接查询与基本查询结合
  * 嵌套查询
    * 无关子查询：父查询与子查询相互独立
    * 相关子查询：相关子查询的结果依赖于父查询的返回值,  EXISTS使用
    * 联机视图：子查询出现在From子句中,可以和其它表一样使用  
  * 查询结果的连接：
    * 并：Union和Union All
    * 交：Minus
    * 差：Intersects

#### 视图

* 视图给出了SQL数据库的外模式定义
  * 视图是从一个或几个基本表中导出的虚拟表，其数据没有实际存储，但可以和表一样操作  
    * 视图具有和表一样的逻辑结构定义
    * 但视图没有相应的存储文件，而每个表都有相应的存储文件  
* 视图的用途
  * 逻辑数据独立性
  * 简化了用户眼中的数据
  * 对不同用户提供不同的数据呈现方式
  * 安全保护
* 视图的定义：Create View
* 视图的查询 ：Select
* 视图的更新：Update。 view只是虚拟表，实际更新会映射到基本表的语句去执行
  * 有一些表不能更新：
    * 基于连接查询的视图不可更新
    * 使用了函数、表达式、 Distinct的视图不可更新
    * 使用了分组聚集操作的视图不可更新  
  * 只有建立在单个表上，而且只是去掉了基本表的某些行和列，但保留了主键的视图才是可更新的  
* 视图的删除：Drop

#### 补充： 几个常用的特殊查询

* Limit：限制返回前多少行
* All，Some，Any：要求子查询中所有/某个条件满足
* Outer Join：连接时同时返回不匹配的结果



## 第5章 过程化SQL

#### 过程化SQL vs. SQL

* 过程化SQL支持一些过程性语言特性
* SQL本身并不能建立数据库应用程序
* 过程化SQL和SQL均可以在DBMS中运行，可以相互调用
* 过程化SQL可以让客户机减少计算以及与服务器间的网络传输：执行一个预先编写好并存储在服务器上的过程化SQL程序完成任务
* 两者比较：ppt8

#### 过程化SQL编程

* 过程化SQL的程序结构

  * 在一次会话里使用过程化SQL：
    * 赋值，输出，表达式计算，函数等
    * 不能使用：流程控制语句、语句块Begin...End、定义局部变量
  * 在存储过程和触发器中编程
    * 支持全部的过程化程序设计要素
    * 支持事务编程

* 过程化SQL对SQL的主要扩展

  * 输入输出：
    输出： select，输入： NA
  * 程序块定义： Begin……End
  * 变量
  * 流程控制：顺序结构/分支结构/循环结构
  * 出错处理
  * 游标
  * 过程：存储过程/函数、触发器  

* 变量：局部变量(DECLARE)、会话变量(不用预先定义，变量名前加@符号，为全局变量）、系统变量(有@@符号，只能读取)

  * 变量的赋值：Set赋值，Select ... Into赋值

* 分支控制语句

  * IF THEN ELSEIF THEN ... ELSE...  END IF;

  * CASE 

    ​    WHEN ..  THEN

    ​	WHEN ..  THEN

    ​	ELSE

    END CASE;

  * 循环语句

    * WHILE ... Do ... End While;
    * REPEAT ... Until ... End Repeat;
    * LOOP: 无内部控制结构，必须Leave显式退出循环

* 异常处理

  * 使用错误陷阱，捕捉程序运行中出现的错误或意外情况，并加以处理
  * 基本方法 ppt21
    * NOT FOUND
    * SQLEXCEPTION
  * 一般的错误处理框架：ppt25

#### 事务编程

* 事务：不可分的DML操作序列
  * 性质：原子性、一致性、独立性、稳定性

* 何时使用事务：当过程化SQL需要对多个数据更新时，要想让他们要么所有语句都生效，要么都失败
* 编程语句：ppt27 ， START TRANSACTION, COMMIT,  ROLLBACK

#### 游标（cursor）

* 游标概念
  * 过程化SQL如何支持多行记录的操作？
  * 游标是客户机或数据库服务器上开辟的一块内存，用于存放SQL返回的结果；存储过程/函数可以通过游标来存取SQL返回的结果
* 游标操作：ppt32-36
  * 声明一个游标：Declare
  * 打开游标：会分配内存，并把select的结果存进去，Open
  * 读取游标中的记录：用循环一条一条读， Fetch ... Into, 循环退出有多种方式，如异常处理
  * 关闭游标：Close
* 游标属性
* 使用游标FOR循环
* 操纵游标的当前行

#### 存储过程

* 存储过程: 存储在数据库中的过程，可以随时运行，也可以被SQL或外部程序调用
  * 存储过程定义：ppt39-40
    * Create Procedure 名（参数表） BEGIN END;
    * 参数定义
    * 查看存储过程：Show Create Procedure
    * Drop Procedure
* 函数：具有返回值的存储过程
  * 定义：ppt43
* 总结：存储过程/函数 的主要作用

#### 触发器

* 触发器的概念
  * 与特定表关联的存储过程
  * 触发操作：Update，Insert，Delete
  * 一个触发器只能属于一个表，一个表可以有多个触发器
  
* 触发器的种类
  * 按执行先后：先触发器、后触发器、替代触发器
  * 按执行方式：行级触发器、语句级触发器
  * 特殊的触发器：DDL触发器、DB事件触发器
  * 在各大数据库里的实现情况：ppt50
  
* 触发器的创建
  * ppt51
  * 没有参数； 一个触发器只能定义一个触发事件（Mysql里）
  
* old和new系统变量
  * 对于行级触发器，old和new存储每一行更新前和后的值
  
* 总结：触发器的主要作用

  * 强化约束：触发器能够实现复杂的约束。
  * 跟踪变化：触发器可以侦测数据库内的操作，可以用来实施审计，以及不允许数据库中未经许可的更新和变化。
  * 级联运行：触发器可以侦测数据库内的操作，并自动地级联影响整个数据库的各项内容  

  * 缺点：影响性能；潜在的运行错误风险  



## 第6章 关系数据库模式设计

* 数据库模式：一般指概念模式

  数据库逻辑设计问题之一：关系数据库的模式设计理论（ 如何把现实世界表达成适合的数据库模式）

  * 功能需求：增删查改
  * 性能需求：并发性、数据量、负载

#### 关系模式的设计问题

* 不规范设计带来的问题
  * 数据冗余
  * 更新异常：数据冗余时更新要更新多行，若有漏掉的，DBMS无法获知这种不一致
  * 插入异常：可能主码设置不合理导致
  * 删除异常：如教师不带课了，会连带把其地址、电话等信息也删去
* 如何解决
  * 模式分解：例子ppt13
  * 什么样的模式是最佳的，如何分解才能达到要求？标准是什么？如何实现？

#### 函数依赖

##### 什么是函数依赖（FD）

* 一个关系模式中一个属性集x和另一个属性集y间的多对一关系(给定一个x，存在唯一的y满足f: x->y) ，X->Y叫做 Y函数依赖于X 或 X函数决定Y

* FD是与具体应用相关的，需要根据现实世界情况来断言

* FD是关系模式的一部分

  ![image-20210702205929463](D:\科大\大三下\数据库\image\image-20210702205929463.png)

* 平凡FD和不平凡FD：ppt20
  * 确定关系模式的最小函数依赖集：可通过消除平凡FD来做
  * 模式设计的首要问题是确定关系模式的最小函数依赖集  
  
* 函数依赖集的闭包 ppt21
  * 函数依赖的逻辑蕴涵
  * 闭包 F+： 被函数依赖集F逻辑蕴涵的函数依赖的全体构成的集合称为F的闭包
  * 函数依赖的推理规则：自反律、增广律、传递律、自含律、分解律、合并律、复合律
  
* 属性集的闭包：用来判断某个函数依赖是否能从F中推出 ppt25-26

##### 码的定义

* 码的形式化定义：ppt24 ，即通过函数依赖来求出超码、候选码

##### 最小函数依赖集

* 函数依赖集的等价和覆盖

  * S2覆盖S1是包含关系
  * 等价：互为覆盖。   DBMS中只要实现任意一个FD集，就可自动实现另一个等价的FD集

* F是最小函数依赖集的充要条件：ppt28 共3个条件

  ![image-20210702210802123](D:\科大\大三下\数据库\image\image-20210702210802123.png)

  且最小函数依赖集也可能有多个

* 求最小函数依赖集：步骤及例子见ppt30

#### 关系模式的分解

##### 概念

* 模式分解的含义：
  * 属性集的分解
  * 函数依赖集的分解
* 模式分解的标准
  * 具有无损连接
  * 要保持函数依赖
  * 既具有无损连接，又要保持函数依赖

##### 无损连接

* 动机：模式分解的过程应该是可逆的，即R的所有数据在分解后应该没有丢失 ，例子ppt35
* 概念：形式化定义通过自然连接 ， ppt36-37
* 无损连接的测试
  * 方法1：Chase，算法流程见ppt40起
  * 方法2：当R只分解为两个关系模式时的简单方法

##### 保持函数依赖

* 关系模式R的FD集在分解后仍在数据库模式中保持不变   （逻辑蕴涵）
* 保持函数依赖的形式化描述以及函数依赖的投影定义：ppt46
* 不保持函数依赖带来的问题：会破坏语义完整性（因为违反原函数依赖）， 此时只能通过触发器等来判断插入等是否正确

#### 关系模式的范式

##### 范式的概念

* 范式：满足特定要求的模式，可以作为衡量一个关系模式好坏的标准

* 规范化：低一级范式的关系模式通过模式分解转换为高一级范式
* 重点是1,2,3NF，  BCNF也要看
* 1->2->3NF ，保证无损和函数依赖；     3NF->BCNF：只保证无损连接

##### 函数依赖图

* FD集可由函数依赖图表达，箭头表示函数决定关系
* 每个候选码必有箭头指出

##### 1NF

* 满足元组的每一个属性值只含有一个值

##### 2NF

* 假定R只有一个候选码，且该候选码为主码。 在1NF基础上，R的每一个非主属性都 完全函数依赖 于主码
* 完全函数依赖和局部函数依赖：ppt55
* 例子：ppt56-57
* 不满足2NF带来的问题：插入异常、删除异常、更新异常、数据冗余
* 模式分解以满足2NF

##### 3NF

* 假定R只有一个候选码，且该候选码为主码。2NF基础上，R的每一个非主属性都不传递依赖于主码
* 传递依赖：ppt60 
* 不满足3NF带来的问题：插入异常、删除异常、更新异常、数据冗余
* 分解2NF到3NF：去掉传递依赖

##### BCNF

* 扩充3NF，可以处理R有多个候选码的情形。如果关系模式R的所有不平凡的、完全的函数依赖的左部(称为决定因素)都是候选码   

* 多候选码例子

* 存在的问题：数据冗余、更新异常、删除异常、插入异常

* 3NF->BCNF

* BCNF例子：ppt68， 函数依赖图中，箭头都是从候选码引出

  ppt69：分解到BCNF不一定能保持函数依赖

##### 规范化过程总结

* ppt70-71 ，  以投影来分解，以自然连接来重构
* ppt72：定理：BCNF可以达到无损连接，但不一定保持函数依赖

##### 模式分解的几个算法

对 R<U,F>

* 算法1：保持函数依赖地分解到3NF

  * 求最小函数依赖集F
  * 把不在F中出现的属性组成一个关系模式，并从U中去掉
  * 判断
  * 对F按相同的左部分组

  例子ppt75

* 算法2：无损并且保持函数依赖地分解为3NF

  * 先用算法1得到分解的集合q
  * q并上R(X)， X为R的主码，若X是q中某个Ri的子集，则去掉R(X)
  * 实际上，当主码是单属性时，R(X)必在q中，所以此时算法2等价于算法1

* 算法3：无损分解为BCNF

##### 4NF

##### 5NF

## 第7章 数据库设计

* 定义：对具体应用环境，构造合适的数据库模式，并利用DBMS构建数据库机器应用系统
* 数据库设计方法：规范化设计方法（运用软件工程的思想方法）
  * 新奥尔良方法：需求分析、概念设计、逻辑设计、物理设计
  * 基于ER模型的方法
  * 基于关系模式的设计方法
  * 基于3NF的设计方法
  * 计算机辅助数据库设计方法
* 我们的选择：以新奥尔良方法为基础，基于ER模型和关系模式，采用计算机辅助进行数据库设计 
  * 概念设计：基于ER模型 
  * 逻辑设计：基于关系模式设计 
  * 计算机辅助设计工具：Power designer

### 数据库设计步骤

#### 需求分析

![image-20210703105720413](D:\科大\大三下\数据库\image\image-20210703105720413.png)

* 输入：总体信息需求、处理需求、DBMS特征
* 输出：数据库设计说明书（完整的数据库逻辑结构 和物理结构、应用程序设计说明）

#### 概念设计

* 产生反映组织信息需求的数据库概念结构， 即概念模型 
  * **概念模型独立于数据库逻辑结构、DBMS以及计 算机系统** 
  * 概念模型以一组ER图形式表示 
* 概念设计侧重于数据内容的分析和抽象，以 用户的观点描述应用中的实体以及实体间的 联系

##### ER模型

* ER模型要素：实体（实体属性）、实体间联系（联系类型、联系属性）
* 实体：唯一标识，称为码(key)
* 联系：与实体属性作区分：不与任何实体发生联系而固有的属性是实体属性
  * 联系的类型：1:1；1:N；M:N
  * 联系的确定：联系的确定依赖于实体的定义和特定的应用 ，同样的实体在不同应用中可能有不同的联系
* ER图符号：ppt16，17

##### ER设计的步骤

自顶向下进行需求分析，自底向上进行ER设计 

* **分ER模型设计（局部ER图）** 
  * 通过实体、联系和属性对子系统的数据进行抽象，产生分ER图 
    * 确定实体：实体是一个属性的集合(数据结构、数据流、数据存储) ； 只考虑应用范围内的实体
    * 确定实体属性 ：
      * 首先确定实体的码 
      * 只考虑系统范围内的属性 
      * 属性应具有域 
      * 属性一般要满足下面的准则 
        * 属性必须不可分，不能包含其它属性 
        * 属性不能和其它实体具有联系
    * 确定联系和联系属性
      * 根据数据需求的描述确定
      * 联系的基数
  * **设计原则：**
    * 实体要尽可能得少 
    * 现实世界中的事物若能作为属性就尽量作为属性对待
* **ER模型集成** 
  * 确定公共实体 
  * 合并分ER图 
  * 消除冲突
    * 属性冲突：类型冲突、值冲突 ，例如性别、年龄 
    * 结构冲突：实体属性集不同、联系类型不同、同一对象在不同应用中的抽象不同 
    * 命名冲突：同名异义、异名同义，如 实体命名冲突、属性命名冲突、联系命名冲突
* **ER模型优化**
  * 目标： 实体个数要少，属性要少，联系尽量无冗余 
  * 具体优化手段： 
    * 合并实体类型：	
      1. 一般1:1联系的两个实体可以合并为一个实体 
      2. 如果两个实体在应用中经常需要同时处理， 也可考虑合并
    * 消除冗余属性：分ER图中一般不存在冗余属性，但集成后可能产生冗余属性
      * 冗余属性的几种情形：同一非码属性出现在几个实体中（一般只允许候选码冗余） 、一个属性值可从其它属性值中导出
    * 消除冗余联系：ppt37-39例子

##### ER模型的扩展

如区分领导者和职工

* 弱实体：一个弱实体的存在必须以另一实体的存在为前提，弱实体所依赖存在的实体称为常规实体（regular entity）或强实体（strong entity)。 弱实体有自己的标识，但它的标识只保证对于所依赖的强实体而言是唯一的。在整个系统中没有自己唯一的实体标识

  * 如何判断是否是弱实体：ppt43

  * 弱实体的表示图：ppt44

    双线矩形，双线菱形

* 子类与超类（继承）

  * 子类：特殊化； 超类：一般化
  * 子类的标识就是超类的标识，且继承了超类的全部属性
  * 在ER设计时，可以根据实际情况增加子类， 也可以根据若干实体抽象出超类
  * 符号及例子：ppt46-47
  * 要想设计子类实体：必须是子类有额外属性

#### 逻辑设计

* 根据概念模型设计出与DBMS支持的数据模型相符合的数据库逻辑结构 ，主要是概念模式和外模式的设计

##### 主要工作 

* ER模型向关系模型的转换 
* 关系模型优化 
* 关系模型修正

##### 步骤

1. ER模型转换成关系数据库模式 
2. 关系数据库模式的规范化 （参考CH6)
3. 模式评价 
4. 模式修正 
5. 最终产生一个优化的全局关系数据库模式 
6. 子模式设计（指外模式）

##### ER模型向关系模型转换

* 数据库逻辑设计步骤

  ![image-20210703115215588](D:\科大\大三下\数据库\image\image-20210703115215588.png)

* 基本ER模型的转换
  
  * 实体转换：每个实体转换为一个关系模式，实体的属性为关系模式的属性，实体的标识成为关系模式的主码
  * 联系转换 
    * 1:1：将任一端的实体的标识和联系属性加入另一实体所对应的关系模式中，两模式的主码保持不变 
    * 1:N：将1端实体的标识和联系属性加入N端实体所对应的关系模式中，两模式的主码不变 
    * M:N：新建一个关系模式，该模式的属性为两端实体的标识以及联系的属性，主码为两端关系模式的主码的组合
  
* 扩展ER模型的转换
  * 弱实体转换 
    * 每个强实体转换为一个关系模式，强实体的属性成为关系模式的属性，实体标识成为主码 
    * 每个弱实体转换为一个关系模式，并加入所依赖的强实体的标识，关系模式的主码为弱实体的标识加上强实体的标识 
  * 子类转换 ：父类实体和子类实体都各自转换为关系模式，并在子类关系模式中加入父类的主码，子类关系模式的主码设为父类的主码

##### 关系数据库模式的规范化

* 确定范式级别：
  * 根据数据依赖确定已有的范式级别 
    * 根据需求写出数据库模式中存在的所有函数依赖 
    * 消除冗余数据依赖，求出最小的依赖集 
    * 确定范式级别
  * 根据实际应用的需要（处理需求）确定要达到的范式级别 ：**时间效率和模式设计问题之间的权衡** 
    * 范式越高，模式设计问题越少，但连接(join)运算越多， 查询效率越低 
    * 如果应用对数据只是查询，没有更新操作，则非 BCNF范式也不会带来实际影响 
    * 如果应用对数据更新操作较频繁，则要考虑高一级范式以避免数据不一致
    * 实际应用中一般以3NF为最高范式
* 实施规范化处理：ch6

##### 模式评价

* 检查规范化后的数据库模式是否完全满足用户需求，并确定要修正的部分 
  * 功能评价：检查数据库模式是否支持用户所有的功能要求 
    * 必须包含用户要存取的所有属性 
    * 如果某个功能涉及多个模式，要保证无损连接性
  *  性能评价：检查查询响应时间是否满足规定的需求。 
    * 由于模式分解导致连接代价 
    * 如果不满足，要重新考虑模式分解的适当性 
    * 可采用模拟的方法评价性能：关键是并发数以及数据量

##### 模式修正

* 根据模式评价的结果，对已规范化的数据库模式进行修改 	

  * 若功能不满足，则要增加关系模式或属性 

  * 若性能不满足，则要考虑属性冗余或降低范式 

    * 合并：若多个模式具有相同的主码，而应用主要是查询，则可合并，减少连接开销 

    * 分解：对模式进行必要的分解，以提高效率  （**出发点：减少数据量**，甚至可将database放入内存)

      * 水平分解 :例子ppt67

        冷热数据划分：将20%热数据单独划分为一个模式，使得大部分的查询都可以在较小规模的数据集上执行

      * 垂直分解 ：把关系模式按属性集垂直分解为多个模式 

        * 在实际中，应用可能经常存取的只是关系的某几个列，可考虑将这些经常访问的列单独拿出组成一个关系模式 
        * 若一个关系中，某几个属性的值重复较多， 并且值较大，可考虑将这些属性单独组成关系模式，以降低存储空间

      * 分库分表

##### 设计用户子模式（视图）

* 即外模式设计
* 设计时的考虑
  * 使用更符合用户习惯的别名：ER图集成时要消除命名冲突以保证关系和属性名的唯一， 在子模式设计时可以重新定义这些名称，以符合用户习惯 
  * 给不同级别的用户定义不同的子模式，以保证系统安全性 
  * 简化用户程序对系统的使用 可将某些复杂查询设计为子模式以方便使用

#### 物理设计

##### 设计数据库的物理结构 

* 为关系模式选择存取方法 
  * 存取方法：数据的存取路径 。例如图书查询 
    * 索引存取方法 
    * 聚簇存取方法 
    * 散列存取方法
  * 存取方法的选择目的是加快数据存取的速度 
  * 索引设计的问题： 哪些表上需要索引？ 哪些字段上需要索引？ 某个字段上的索引具体选择哪一种？
* 设计数据库的存储结构 
  * 确定数据的存放位置 
    * 针对应用环境和DBMS特性，合理安排数据存储位置 
      * 表和索引可考虑放在不同的磁盘上，使查询时可以并行读取 
      * 日志文件和备份文件由于数据量大，而且只有恢复时使用，可放到磁带上 
  * 确定系统配置：系统初始参数不一定适合应用 
    * 并发用户数、同时打开的数据库对象数、缓冲区分配参 数、物理块的大小等

##### 物理设计的考虑 

* 查询时间效率 
* 存储空间 
* 维护代价 

##### 物理设计依赖于给定的计算机系统

#### 数据库实施

* 建立实际的数据库结构
* 初始数据装入
* 安全性设计和故障恢复设计
* 应用程序的编码和调试：存储过程、触发器等的实现

#### 数据库运行与维护

* 试运行
  * 根据初始数据对数据库系统进行联调 
  * 执行测试：功能、性能
* 维护
  * 数据备份和恢复
  * 数据库安全性控制和完整性控制 
  * 数据库性能的分析和改造 
  * 数据库的重组织



## 第8章 数据库索引

为何DBMS底层需要按页存取

* ![image-20210703152057008](D:\科大\大三下\数据库\image\image-20210703152057008.png)
* ![image-20210703152102115](D:\科大\大三下\数据库\image\image-20210703152102115.png)

为什么数据库需要索引

* 没有索引，数据查询效率低
* ![image-20210703152258649](D:\科大\大三下\数据库\image\image-20210703152258649.png)

#### 顺序文件上的索引

* 顺序文件：记录按查找键排序

##### 密集索引

* 每个记录都有一个索引项
  索引项按查找键排序 
* ![image-20210703152550855](D:\科大\大三下\数据库\image\image-20210703152550855.png)
* ![image-20210703152802894](D:\科大\大三下\数据库\image\image-20210703152802894.png)

##### 稀疏索引

* 仅部分记录有索引项
  一般情况：为每个数据块的第一个记录建立索引
*   ![image-20210703153105735](D:\科大\大三下\数据库\image\image-20210703153105735.png)
* 有何优点？
  * 节省了索引空间
  * 对同样的记录，稀疏索引可以使用更少的索引项
* 有何缺点？
  * 对于“是否存在键值为K的记录？”，需要访问磁盘数据块  
  * 若稀疏索引无序，则稀疏索引不适用

##### 多级索引

* 索引上再建索引：二级索引、三级索引  

* ![image-20210703153311904](D:\科大\大三下\数据库\image\image-20210703153311904.png)

* 多级索引的好处？

  * 一级索引可能还太大而不能常驻内存
  * 二级索引更小，可以常驻内存
  * 减少磁盘I/O次数  

  ![image-20210703153736712](D:\科大\大三下\数据库\image\image-20210703153736712.png)

* 当一级索引过大而二级索引可常驻内存时有效

  * 二级索引仅可用稀疏索引
    思考：二级密集索引有用吗？不可以，这样两级索引是1:1，冗余了
  * 一般不考虑三级以上索引
    * 维护多级索引结构有代价
    * 有更好的索引结构——B＋树  

#### 辅助索引

* ![image-20210703154200716](D:\科大\大三下\数据库\image\image-20210703154200716.png)

* 辅助索引只能是密集索引
  稀疏的辅助索引无意义：对缩小搜索范围没有帮助

* ![image-20210703154458719](D:\科大\大三下\数据库\image\image-20210703154458719.png)

* 重复键值的处理

  * 采用密集索引浪费空间  

  * 引入间接桶：介于辅助索引和数据文件之间  

  * 辅助索引中的间接桶

    ![image-20210703155140644](D:\科大\大三下\数据库\image\image-20210703155140644.png)

##### 倒排索引

* 应用于文档检索，与辅助索引思想类似

  * 不同之处
    记录->文档
    记录查找->文档检索
    查找键-> 文档中的词
  * 思想
    为每个检索词建立间接桶
    桶的指针指向检索词所出现的文档  

  ![image-20210703155421278](D:\科大\大三下\数据库\image\image-20210703155421278.png)

* 也可以扩充倒排索引的桶以包含更多信息

#### B+树

* ![image-20210703155646724](D:\科大\大三下\数据库\image\image-20210703155646724.png)

* 叶结点

  ![image-20210703160019032](D:\科大\大三下\数据库\image\image-20210703160019032.png)

* 中间结点

  ![image-20210703160213402](D:\科大\大三下\数据库\image\image-20210703160213402.png)

* B+树查找

  从根结点开始
  沿指针向下，直到到达叶结点
  在叶结点中顺序查找  

* B+树插入

  查找插入叶结点
  若叶结点中有空闲位置（键），则插入
  若没有空间，则分裂叶结点

  * 叶结点的分裂可视作是父结点中插入一个子结点
  * 递归向上分裂
  * 分裂过程中需要对父结点中的键加以调整
  * 例外：若根结点分裂，则需要创建一个新的根结点  

  例子见ppt36-39

* B+树删除

  查找要删除的键值，并删除之
  若结点的键值填充低于规定值，则调整

  * 若相邻的叶结点中键填充高于规定值，则将其中一个键值移到该结点中
  * 否则，合并该结点与相邻结点
    合并可视作在父结点中删除一个子结点
  * 递归向上删除

  若删除的是叶结点中的最小键值，则需对父结点的键值加以调整  

* B+树的效率

  * 访问索引的I/O代价＝树高（ B＋树不常驻内存）或者0（常驻内存）
    树高通常不超过3层，因此索引I/O代价不超过3（总代价不超过4）

  * 通常情况下，根节点常驻内存，因此索引I/O代价不超过2（总代价不超过3）  

  * B+树支持点查询、范围查询、更新代价高

#### 散列表

* ![image-20210703163105994](D:\科大\大三下\数据库\image\image-20210703163105994.png)

* ![image-20210703163159463](D:\科大\大三下\数据库\image\image-20210703163159463.png)

* 散列表概念

  ![image-20210703163226192](D:\科大\大三下\数据库\image\image-20210703163226192.png)

* 散列表查找

  对于给定的散列键值k，计算h(K)
  根据h(K)定位桶
  查找桶中的块  

* 散列表插入

  计算插入记录的h(K)，定位桶
  若桶中有空间，则插入
  否则创建一个溢出块并将记录置于溢出块中  

  若h(K)设计得不好，则hash冲突会很严重

  ![image-20210703163536617](D:\科大\大三下\数据库\image\image-20210703163536617.png)

* 散列表删除

  根据给定键值K计算h(K)，定位桶和记录
  删除：回收溢出块

* 散列表空间利用率问题

  空间利用率

  * 实际键值数 / 所有桶可放置的键值数
    <50％：空间浪费
    \>80％：容易产生溢出块，降低查询性能
    50％到80％之间（ GOOD！）  

  动态散列表：桶大小随着插入记录数而变化，始终维持50%-80%的空间利用率

* 文件增长

  数据文件的增长使桶的溢出块数增多，增加I/O

  采用动态散列表解决

  1. 可扩展散列表（ Extensible Hash Tables）：成倍增加桶数目

     优点：不存在溢出块，查询都只要一次I/O，但空间代价很高

  2. 线性散列表（ Linear Hash Tables）：线性增加  

* 可扩展散列表

  即任意一个索引通过h（）会映射为一个b位二进制序列，根据此序列找到对应的桶

  ![image-20210703164202905](D:\科大\大三下\数据库\image\image-20210703164202905.png)

  ![image-20210703164612828](D:\科大\大三下\数据库\image\image-20210703164612828.png)

  例子见ppt58-61

  **优点：**
  当查找记录时，只需查找一个存储块。
  **缺点：**
  桶增长速度快，可能会导致内存放不下整个桶数组，影响其他保存在主存中的数据，波动较大  

* 线性散列表

  ![image-20210703165227517](D:\科大\大三下\数据库\image\image-20210703165227517.png)

  ![image-20210703165508834](D:\科大\大三下\数据库\image\image-20210703165508834.png)

  例子见ppt65-67

  总结

  * 空间效率优于可扩展散列表
  * 查找性能比可扩展散列表差
  * 综合性能较好  

![image-20210703165831287](D:\科大\大三下\数据库\image\image-20210703165831287.png)



## 第10章 事务与恢复

* 数据库保护：预防各种对数据库的干扰破坏，确保数据安全可靠，以及在数据库遭到破坏后尽快地恢复

  * 乐观机制： 事后恢复
  * 悲观机制： 事前预防

* 数据库保护通过四个方面来实现

  * 完整性控制技术
    Enable constraints
  * 安全性控制技术
    Authorization and authentication

  * 数据库的恢复技术 Deal with failure

  * 并发控制技术
    Deal with data sharing

#### 事务的状态及原语操作

* 事务(transaction)：一个不可分割的操作序列，其中的操作要么都做，要么都不做 

  例子：如银行转账

*  事务的ACID性质

  * 原子性 Atomicity
    事务是不可分的原子，其中的操作要么都做，要么都不做
  * 一致性 Consistency
    事务的执行保证数据库从一个一致状态转到另一个一致状态
  * 隔离性 Isolation
    多个事务一起执行时相互独立
  * 持久性 Durability
    事务一旦成功提交，就在数据库永久保存（写入磁盘而非内存）

  * 其中ACD要么有要么无，I有不同级别

* 事务的状态

  <Start T>
  Transaction T has started
  <Commit T>
  T has finished successfully and all
  modifications are reflected to disks
  <Abort T>

  T has been terminated and all modifications have been canceled

* 事务的原语操作

  * Input (x): disk block with x → memory 磁盘到内存读
  * Output (x): buffer block with x → disk 内存到磁盘写
  * Read (x,t): do input(x) if necessary
    t ← value of x in buffer 从buffer读数
  * Write (x,t): do input(x) if necessary
    value of x in buffer ← t   把数写入buffer

  ![image-20210703171030249](D:\科大\大三下\数据库\image\image-20210703171030249.png)

* 事务例子

  ![image-20210703171122607](D:\科大\大三下\数据库\image\image-20210703171122607.png)

* SQL对事务的支持

  mysql：Start transaction/commit/rollback  

#### 数据库的一致性和正确性

##### 一致性Consistency

* 完整性约束=一致性约束

  即实体完整性、参照完整性、用户自定义完整性

* Consistent state: 满足所有完整性约束
  Consistent DB: DB in consistent state  

* ![image-20210703172216910](D:\科大\大三下\数据库\image\image-20210703172216910.png)

  事务内部允许不保证DB的一致性

* 所以需要数据库恢复：基于日志：Undo或Redo日志

##### 正确性Correctness

* DB应该反映现实世界，如电话号码格式（可设置自定义约束），但

  ![image-20210703172702531](D:\科大\大三下\数据库\image\image-20210703172702531.png)

  ![image-20210703172631193](D:\科大\大三下\数据库\image\image-20210703172631193.png)

* 如果数据库在事务开始执行时是一致的，并且事务执行结束后数据库仍处于一致状态，则数据库满足正确性  

  所以数据库的正确性不等于现实的正确性

  ![image-20210703172804112](D:\科大\大三下\数据库\image\image-20210703172804112.png)

#### 数据库系统故障分析

数据库的一致性可能由于故障而被破坏

##### 事务故障

* 发生在单个事务内部的故障（不影响其他事务）
  * 可预期的事务故障
    即应用程序可以发现的故障，如转帐时余额不足。由应用程序处理
  * 非预期的事务故障
    如运算溢出等，导致事务被异常中止。应用程序无法处理此类故障，由系统进行处理  

##### 介质故障

![image-20210703173141298](D:\科大\大三下\数据库\image\image-20210703173141298.png)

##### 系统故障

* 系统故障：软故障（ Soft Crash），由于OS、 DBMS软件问题或断电等问题导致内存数据丢失，但磁盘数据仍在
* 影响所有正在运行的事务，破坏事务状态，但不破坏整个数据库  
* 需重启，作故障恢复

##### 数据库系统故障恢复策略

* 目的：恢复DB到最近的一致状态
* 基本原则
  冗余（ Redundancy）![image-20210703173619543](D:\科大\大三下\数据库\image\image-20210703173619543.png)
* 实现方法
  * 定期备份整个数据库
  * 建立事务日志 (log)
  * 通过备份和日志进行恢复  
* ![image-20210703173909536](D:\科大\大三下\数据库\image\image-20210703173909536.png)

#### Undo日志

* 事务日志记录了所有**更新操作**的具体细节
  Undo日志、 Redo日志、 Undo/Redo日志
* 日志文件的登记严格按事务执行的时间次序  ,且为append only

* Undo日志文件中的内容
  事务的开始标记（ <Start T>）
  事务的结束标记（ <Commit, T>或<Abort T>）
  事务的更新操作记录，一般包括以下内容

  * 执行操作的事务标识
  * 操作对象
  * 更新前值（插入为空  

* Undo与Redo的区别

  ![image-20210703174147992](D:\科大\大三下\数据库\image\image-20210703174147992.png)

* Undo日志规则

  ![image-20210703174343014](D:\科大\大三下\数据库\image\image-20210703174343014.png)

  先写日志原则WAL

  ![image-20210703174502574](D:\科大\大三下\数据库\image\image-20210703174502574.png)

  例子：ppt35-39

* 基于Undo日志的恢复

  ![image-20210703174919440](D:\科大\大三下\数据库\image\image-20210703174919440.png)

  ![image-20210703175112350](D:\科大\大三下\数据库\image\image-20210703175112350.png)

* 总结

  <T,x,v>记录修改前的旧值
  写入<Commit,T>之前必须先将数据写入磁盘
  恢复时忽略已提交事务，只撤销未提交事务：有<Commit,T>的事务肯定已写回磁盘  

#### Redo日志

* 在x被写到磁盘之前，对应该修改的Redo日志记录必须已被写到磁盘上 (WAL)

* 在数据写回磁盘前先写<Commit,T>日志
  记录
  日志中的数据修改记录
  <T, x, v> - - Now v is the new value 

* Redo日志规则：例子ppt47-52

* 基于Redo日志的恢复

  ![image-20210703175731107](D:\科大\大三下\数据库\image\image-20210703175731107.png)

  恢复的基础

  * 没有<Commit,T>记录的操作必定没有改写磁盘数据，因此在恢复时可以不理会
    Differ from Undo logging
  * 有<Commit,T>记录的结果可能还未写回磁盘，因此在恢复时要Redo
    Still differ from Undo logging  

* ==Undo vs Redo==

  Undo基于立即更新 (Immediate Update)
  Redo基于延迟更新 (Deferred Update) 

  Redo更常用，如MysQL 

#### Undo/Redo日志

* ![image-20210703180224149](D:\科大\大三下\数据库\image\image-20210703180224149.png)

* 基于Undo/Redo日志的恢复

  ![image-20210703180426558](D:\科大\大三下\数据库\image\image-20210703180426558.png)

  ![image-20210703180617303](D:\科大\大三下\数据库\image\image-20210703180617303.png)

#### Checkpoint  

* 当系统故障发生时，必须扫描日志。需要搜索整个日志来确定UNDO列表和REDO列表
  * 搜索过程太耗时，因为日志文件增长很快
  * 会导致最后产生的REDO列表很大，使恢复过程变得很长  

* 基于检查点的恢复

  * 设置检查点

    ![image-20210703180827071](D:\科大\大三下\数据库\image\image-20210703180827071.png)

  * 恢复

    ![image-20210703180804126](D:\科大\大三下\数据库\image\image-20210703180804126.png)



## 第11章 并发控制

多个事务同时存取共享的数据库时，如何保证数据库的一致性？  

#### 并发操作与并发问题

* 并发操作

  * 在多用户DBS中，如果多个用户同时对同一数据进行操作称为并发操作
  * 并发操作使多个事务之间可能产生相互干扰，破坏事务的隔离性(Isolation) 
  * DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的一致性，避免产生不正确的数据

* 并发操作通常会引起三类问题（ 三大并发问题），例子ppt8-10

  * 丢失更新（ Lost update）

  * 脏读（ Dirty read / Uncommitted update）

    脏数据：事务在内存中更新了但还未最终提交的数据  

  * 不一致分析 （ Inconsistent analysis）  

* 并发控制问题讨论

  ppt11-14

* 并发控制的问题该如何解决

  一种方法

  * 让所有事务一个一个地串行执行
    * 一个事务在执行时其它事务只能等待
    * 不能充分利用系统资源，效率低下
  * 另一种方法
    * 为了充分发挥DBMS共享数据的特点，应允许事务内部的读写操作并发执行
    * 挑战
      必须保证事务并发执行的正确性；必须用正确的方法调度执行事务的并发操作  

#### 并发事务调度与可串性(Scheduling and Serializability )

* 调度的例子：ppt16-21

* 调度的定义

  ![image-20210703203229920](D:\科大\大三下\数据库\image\image-20210703203229920.png)

  多个事务的并发执行存在多种调度方式  

* 可串化调度

  * 可串化调度是正确的调度
  * 串行调度 (Serial schedule)
    各个事务之间没有任何操作交错执行，事务一个一个执行
    S ＝ T1 T2 T3 … Tn
  * Serialzable Schedule
    如果一个调度的结果与**某一**串行调度执行的结果等价，则称该调度是可串化调度，否则是不可串调度
  * 可串化调度的正确性
    * Consistence of transaction: 单个事务的执行保证DB从一个一致状态变化到另一个一致状态
    * N个事务串行调度执行仍保证 Consistence of DB  

  那么要如何判断一个schedule是可串化的呢

* 冲突可串性

  * 冲突操作![image-20210703203927222](D:\科大\大三下\数据库\image\image-20210703203927222.png)

    ![image-20210703204041318](D:\科大\大三下\数据库\image\image-20210703204041318.png)

  * ![image-20210703204852805](D:\科大\大三下\数据库\image\image-20210703204852805.png)

  * ![image-20210703204306788](D:\科大\大三下\数据库\image\image-20210703204306788.png)

  * 冲突等价

    如果S1能通过一系列不冲突操作间的顺序交换变成S2的顺序，那称S1和S2冲突等价

  * 冲突可串性：如果某个调度与一个串行调度冲突等价，则该调度是冲突可串

  * 定理：如果一个调度满足冲突可串性，则该调度是可串化调度
    **仅为充分条件**  ，即可串化调度不一定具有冲突可串性

* 优先图

  ![image-20210703204915649](D:\科大\大三下\数据库\image\image-20210703204915649.png)

  例子见ppt37-38

  ![image-20210703205152135](D:\科大\大三下\数据库\image\image-20210703205152135.png)

#### 锁与可串性实现 (Locks)

* 通过锁来实现可串化调度

##### 锁简介

* 锁协议：
  1. Well-formed transactions  ：任何事务先lock，再执行，执行完再unlock
  2. Legal scheduler  ：lock(A)和unlock(A)间不能有其他的lock(A)

##### 两阶段锁（2PL)

* ![image-20210703205848044](D:\科大\大三下\数据库\image\image-20210703205848044.png)

* 两段式事务：遵守2PL协议的事务
  定理:如果一个调度S中的所有事务都是两段式事务，则该调度是可串化调度  

* ![image-20210703210132806](D:\科大\大三下\数据库\image\image-20210703210132806.png)

* X Lock （Exclusive Locks ，也称写锁）
  X锁：若事务T对数据R加X锁，那么其它事务要等T释放X锁以后，才能获准对数据R进行封锁。只有获得R上的X锁的事务，才能对所封锁的数据进行 修改  

  * X锁提供了对事务的写操作的正确控制策略
  * 但如果事务是只读事务，则没必要加X锁
    * 写——独占
    * 读——共享

* Share Locks（ S锁，也称读锁）
  S锁：如果事务T对数据R加了S锁，则其它事务对R的X锁请求不能成功， 但对R的S锁请求可以成功。这就保证了其它事务可以读取R但不能修改R，直到事务T释放S锁。 当事务获得S锁后，如果要对数据R进行修改，则必须在修改前执Upgrade(R)操作，将S锁升级为X锁  

  ![image-20210703210619260](D:\科大\大三下\数据库\image\image-20210703210619260.png)

* 锁的相容性

  ![image-20210703210653003](D:\科大\大三下\数据库\image\image-20210703210653003.png)

* Update Lock 

  前面所讲的upgrade操作可能导致死锁（ppt56），解决方式：

  ![image-20210703210843908](D:\科大\大三下\数据库\image\image-20210703210843908.png)

  ![image-20210703210913721](D:\科大\大三下\数据库\image\image-20210703210913721.png)

  若<U,S>相容，会导致活锁：ppt59

##### 多粒度锁 Multi-granularity lock

* Lock Granularity
  指加锁的数据对象的大小：可以是整个关系、块、元组、整个索引、索引项

* 锁粒度越细，并发度越高；锁粒度越粗，并发度越低  

* ![image-20210703212040153](D:\科大\大三下\数据库\image\image-20210703212040153.png)

* 多粒度锁协议：允许多粒度树中的每个结点被独立地加S锁或X锁，对某个结点加锁意味着其下层结点也被加了同类型的锁

* 为何需要多粒度锁

  ![image-20210703212423372](D:\科大\大三下\数据库\image\image-20210703212423372.png)

  ![image-20210703212428379](D:\科大\大三下\数据库\image\image-20210703212428379.png)

* 多粒度锁上的两种不同加锁方式

  * 显式加锁：应事务的请求直接加到数据对象上的锁

  * 隐式加锁：本身没有被显式加锁，但因为其上层结点加了锁而使数据对象被加锁

  * 给一个结点显式加锁时必须考虑

    * 该结点是否已有不相容锁存在
    * 上层结点是否已有不相容的的锁（上层结点导致的隐式锁冲突）
    * 所有下层结点中是否存在不相容的显式锁（代价不好控制）

    例子：ppt70

* 在对一个结点P请求锁时，必须判断该结点上是否存在不相容的锁

  * 有可能是P上的显式锁
  * 也有可能是P的上层结点导致的隐式锁
  * 还有可能是P的下层结点中已存在的某个显式锁

  理论上要搜索上面全部的可能情况，才能确定P上的锁请求能否成功

  * 显然是低效的
  * 引入意向锁 (Intension Lock) 解决这一问题  

##### 意向锁 Intension Lock

* IS锁（ Intent Share Lock，意向共享锁，
  意向读锁）

  IX锁（ Intent Exlusive Lock，意向排它锁，意向写锁）    

* 如果对某个结点加IS(IX)锁，则说明事务要对该结点的某个下层结点加S (X)锁；
  对任一结点P加S(X)锁，必须先对从根结点到P的路径上的所有结点加IS(IX)锁  

![image-20210703213046269](D:\科大\大三下\数据库\image\image-20210703213046269.png)

* 相容性![image-20210703213106602](D:\科大\大三下\数据库\image\image-20210703213106602.png)

#### 事务的隔离级别

* 并发控制机制可以解决并发问题。这使所有事务得以在彼此完全隔离的环境中运行
  然而许多事务并不总是要求完全的隔离。如果允许降低隔离级别，则可以提高并发性  
* ![image-20210703213521509](D:\科大\大三下\数据库\image\image-20210703213521509.png)
* ![image-20210703213815152](D:\科大\大三下\数据库\image\image-20210703213815152.png)
* ![image-20210703214441332](D:\科大\大三下\数据库\image\image-20210703214441332.png)
* ![image-20210703214449314](D:\科大\大三下\数据库\image\image-20210703214449314.png)
* ![image-20210703215054704](D:\科大\大三下\数据库\image\image-20210703215054704.png)
* 不同隔离级别下DBMS加锁的动作有很大的差别  

#### 死锁  

* 死锁的两种处理策略

  * 死锁检测 Deadlock Detecting
    检测到死锁，再解锁
  * 死锁预防 Deadlock Prevention
    提前采取措施防止出现死锁 

  死锁主要影响DBMS性能，不会破坏数据库的一致性

##### 死锁检测

策略：

* Time Out超时

* 等待图Waiting graph

  ![image-20210703215444703](D:\科大\大三下\数据库\image\image-20210703215444703.png)

##### 死锁预防

策略

* Priority Order：按封锁对象的某种优先顺序加锁  ，并证明按这种方式加锁，永远不会出现死锁

  * 把要加锁的数据库元素按某种顺序排序，事务只能按照元素顺序申请锁  

* Timestamp：使用时间戳

  * 每个事务开始时赋予一个时间戳
  * 如果事务T被Rollback然后再Restart， T的时间戳不变
  * Ti请求被Tj持有的锁，根据Ti和Tj的timestamp决定锁的授予

  两种机制：

  ![image-20210703220045952](D:\科大\大三下\数据库\image\image-20210703220045952.png)

  ![image-20210703220214331](D:\科大\大三下\数据库\image\image-20210703220214331.png)

  两种机制的比较

  ![image-20210703220512331](D:\科大\大三下\数据库\image\image-20210703220512331.png)

  证明两种机制有效：![image-20210703220707440](D:\科大\大三下\数据库\image\image-20210703220707440.png)

##### 再谈锁机制

* 两种并发控制思路

  * 悲观并发控制 --- “悲观锁”
    立足于事先预防事务冲突
    采用锁机制实现，事务访问数据前都要申请锁
    锁机制影响性能，容易带来死锁、活锁等副作用
  * 乐观并发控制
    乐观并发控制假定不太可能（但不是不可能）在多个用户间发生资源冲突，允许不锁定任何资源而执行事务。只有试图更改数据时才检查资源以确定是否发生冲突。如果发生冲突，应用程序必须读取数据并再次试进行更改。

* 乐观并发控制

  * 动机: 如果大部分事务都是只读事务，则并发冲突的概率比较低；即使不加锁，也不会破坏数据库的一致性；加锁反而会带来事务延迟  
  * 基于事后协调冲突的思想，用户访问数据时不加锁；如果发生冲突，则通过回滚某个冲突事务加以解决
    * 由于不需要加锁，因此开销较小，并发度高
    * 但需要确定哪些事务发生了冲突
      使用“有效性确认(Validation)”  
  * 有效性确认协议
    每个更新事务Ti在其生命周期中按以下三个阶段顺序执行
    * 读阶段：数据被读入到事务Ti的局部变量中。此时所有write操作都针对局部变量，并不对数据库更新
    * 有效性确认阶段： Ti进行有效性检查，判定是否可以将write操作所更新的局部变量值写回数据库而不违反可串性
    * 写阶段：若Ti通过有效性检查，则进行实际的写数据库
      操作，否则回滚Ti  

  * 有效性检查方法（即有效性确认阶段）

    基于行版本的乐观并发控制  

    ![image-20210703221420387](D:\科大\大三下\数据库\image\image-20210703221420387.png)

    ![image-20210703221456190](D:\科大\大三下\数据库\image\image-20210703221456190.png)



## 第12章 数据库安全性

#### 数据库安全性控制概述

* 非法使用数据库的情况

  * 用户编写一段合法的程序绕过DBMS及其授权机制，通过操作系统直接存取、修改或备份数据库中的数据；
  * 直接或编写应用程序执行非授权操作；
  * 通过多次合法查询从数据库中推导出一些保密数据  

  ![image-20210703221819881](D:\科大\大三下\数据库\image\image-20210703221819881.png)

  SQL注入问题：ppt7

* ![image-20210703222208140](D:\科大\大三下\数据库\image\image-20210703222208140.png)

* 数据库安全性控制的常用方法

  * 用户标识和鉴定
  * 密码存储
  * 存取控制
  * 视图
  * 审计 

* 存取控制

  存取控制（ Access Control）机制的功能

  * 授权（ Authorization）
    对每个用户定义存取权限
  * 验证（ Authentication）
    对于通过鉴定获得上机权的用户（即合法用户），系统根据他的存取权限定义对他的各种操作请求进行控制，
    确保他只执行合法操作
  * 授权和验证机制一起组成了DBMS的安全子系统  

  常用存取控制方法

  * 自主存取控制（ Discretionary Access Control，简称DAC）
    * C1级
    * 灵活
  * 强制存取控制（ Mandatory Access Control，简称 MAC）
    * B1级
    * 严格  

* 数据安全的级别

  ![image-20210703222705926](D:\科大\大三下\数据库\image\image-20210703222705926.png)

  ![image-20210703222746079](D:\科大\大三下\数据库\image\image-20210703222746079.png)

#### 自主存取控制DAC

* 同一用户对于不同的数据对象有不同的存取权限
  不同的用户对同一对象也有不同的权限
  用户还可将其拥有的存取权限自主地转授给其他用户  

* 存取权限

  * 两要素组成：数据对象、操作类型

  * ![image-20210703223025543](D:\科大\大三下\数据库\image\image-20210703223025543.png)

  * SQL中的存取权限定义方法

    GRANT/REVOKE

    ![image-20210703223109791](D:\科大\大三下\数据库\image\image-20210703223109791.png)

    ![image-20210703223155050](D:\科大\大三下\数据库\image\image-20210703223155050.png)

* 小结

  ![image-20210703223238299](D:\科大\大三下\数据库\image\image-20210703223238299.png)

  DAC不能防止木马：如直接复制文件

#### 强制存取控制MAC

* 每一个数据对象被标以一定的密级（与数据本身绑定在一起）
  每一个用户也被授予某一个级别的许可
  对于任意一个对象，只有具有合法许可的用户才可以存取  

* 主体和客体

  ![image-20210703223709021](D:\科大\大三下\数据库\image\image-20210703223709021.png)

* 敏感度标记

  ![image-20210703223739594](D:\科大\大三下\数据库\image\image-20210703223739594.png)

  最高级为绝密，最低级为公开

* 强制存取控制规则

  ![image-20210703223909483](D:\科大\大三下\数据库\image\image-20210703223909483.png)

* 强制存取控制方法的特点

  ![image-20210703223951363](D:\科大\大三下\数据库\image\image-20210703223951363.png)

* 基于MAC的多级安全数据库

  ![image-20210703224215688](D:\科大\大三下\数据库\image\image-20210703224215688.png)

#### 视图机制  

* ![image-20210703224346822](D:\科大\大三下\数据库\image\image-20210703224346822.png)

例子ppt最后



## 第13章 数据库完整性

#### 数据库完整性概念

* ![image-20210703224858720](D:\科大\大三下\数据库\image\image-20210703224858720.png)

* 完整性控制功能

  完整性控制机制应具有的三个功能

  * 定义功能：提供定义完整性约束条件的机制
  * 检查功能：检查用户发出的操作请求是否违背了约束条件。
    * 立即执行约束（一条语句执行完成后立即检查）
    * 延迟执行约束（整个事务执行完毕后再检查）
  * 如果发现用户操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性  

* 完整性规则定义

  DBA向DBMS提出的一组完整性规则，来检查数据库中的数据是否满足语义约束，主要包括三部分：

  * 触发条件： 系统什么时候使用规则来检查数据
  * 约束条件： 系统检查用户发出的错误操作违背了什么完整性约束条件
  * 违约响应： 违约时要做的事情

  完整性约束规则是由DBMS提供的语句来描述，存储在数据字典，但违约响应由系统来处理  

  ![image-20210704001512429](D:\科大\大三下\数据库\image\image-20210704001512429.png)

#### 完整性约束类型

* 按约束的粒度
  表级约束、列级约束、元组级约束
* 按约束对象的状态
  静态约束、动态约束
* 按约束作用类型分
  域完整性、实体完整性、参照完整性 

##### 按约束粒度分类

* 表级约束： 若干元组间、关系上以及关系之间联系的约束；
* 列级约束： 针对列的类型、取值范围、精度等而制定的约束条件。
* 元组级约束： 单个元组中字段间联系的约束  

##### 按约束对象的状态分类

* 静态约束： 数据库每一确定状态时的数据对象所应满足的约束条件；
  例如：学生关系中年龄不能大于100

* 动态约束： 数据库从一种状态转变为另一种状态时，新、旧值之间所应满足的约束条件
  例如调整工资时须满足：

  现有工资 〉原有工资+工龄*100    

##### 按约束作用类型分类

* 域完整性： 域完整性为为列或列组指定一个有效的数据集，并确定该列是否允许为空

  ![image-20210704002416663](D:\科大\大三下\数据库\image\image-20210704002416663.png)

* 实体完整性： 实体完整性要求表中所有的元组都应该有一个惟一的标识符，这个标识符就是平常所说的主码

  关系模式R的主码不可为空
  指组成主码的所有属性均不可取空值  

* 参照完整性： 参照完整性维护参照表中的外码与被参照表中候选码之间的相容关系。如果在被参照表中某一元组被
  外码参照，那么这一行既不能被删除，也不能更改  

#### 完整性实施途径

##### 约束

* 约束的用途是限制输入到表中的值的范围。约束是实施数据完整性的首选方法。
  SQL中的约束
  * 主键约束（ Primary Key）
  * 唯一键约束（ Unique）
  * 外键约束（ Foreign Key）
  * 检查约束（ Check）
  * 默认值约束（ Default）  

##### 触发器

* 与特定表关联的存储过程。当在该表上执行DML操作时，可以自动触发该存储过程执行相应的操作
  * 触发操作： Update、 Insert、 Delete
  * 通过触发器可以实现复杂的约束  

##### 规则

* ![image-20210704002951027](D:\科大\大三下\数据库\image\image-20210704002951027.png)
* 创建规则
* 绑定规则：将规则绑定到列或用户自定义数据类型。  

##### 断言

## 问题

##### 第10章

立即更新和延迟更新?ppt55-56

Undo/Redo 的commit

为何checkpoint是redo列表

54 页之后

##### ch12

* ppt20：无意泄露

