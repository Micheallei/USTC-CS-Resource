### 问题

* 32.2： 各种复杂度的咋记？

* ppt lec01 最后两个思考题

* ipad书p139： 同时找最小和最大至少次数？？

* 背包问题（ch16）看看代码

* lec06 ppt p12：多段图问题

* fibonacci堆的consolidate第4行，如何遍历？

* fibonacci堆作kruakal？ 好像不太行，因为没有Find-set

* 单源最短路径问题：不满足最优性原理？？？

* 单源简单最短路径问题：满足最优性原理？？？？？

* Pert图？

* ipad书p403

* ipad书p434，关于自乘与闭包

  重复平方技术？？怎么转换为矩阵乘
  
* 15-4.6题







lgn 默认为底数是2

### CH2 算法基础

* 插入排序：原址，时间$O(n^2)$
* 循环不变式：初始化、保持、终止

* 分治法（递归思想：分解、解决、合并）之 归并排序
  * 两个函数

    * MERGE(A,p,q,r):合并两个已排序序列，$\Theta(n)$
    * MERGE_SORT():主函数，递归调用
  * 时间复杂度的递归式：书p20, 式2.1
  * 运行时间$\Theta(nlgn)$
* 树的高度：叶节点为0 ；   树的层数：根结点为第1层

### CH3 函数的增长

* 要求所有函数渐进非负
* $\Theta$记号：存在$c_1,c_2,n_0$，  渐进紧确界
* O记号：渐进上界，存在$c,n_0$
* $\Omega$记号：渐进下界，存在$c,n_0$
* $\Theta$  <---> O + $\Omega$
* 等式与不等式中的渐进记号
* $e^x$泰勒展开及其不等式：书p32
* ln(1+x) 泰勒展开以及不等式 ，p32
* strling公式：3.18，3.20 （p33）
* 多重对数函数
* 斐波那契数
* 证明题思路： 把多项式高次项拆开，一部分保留，另一部分用于放缩来把低阶项可能的负值去除



### CH4 分治策略

* 求解递归式

  * 代入法：猜测+数归

    * 要求紧致

    * 边界条件的说明（可收放）

      解决思路：

      1. 放缩$n_0$（扩展边界条件）:即从$n_0=2，3$等开始
      2. 在先前的猜测中减去低阶项或加上一个值，但保持与所证的O(g(n))同阶

      其他技巧：变量代换化为以前证过的形式

  * 递归树

    * 适合生成好的猜测，再由代入法证明
    * 可以对每层的求和适当放缩：如等比数列求和取极限、忽略一些结点或增加一些结点

  * 主定理：![image-20210112153148040](D:\Typora\ASC\image-20210112153148040.png)

* 矩阵乘法的Strassen算法：$T(n)=\Theta(n^{lg7})$

  ![image-20210112153929944](D:\Typora\ASC\image-20210112153929944.png)

* 矩阵乘法的分治策略 $T(n)=\Theta(n^3)$![image-20210112155326118](D:\Typora\ASC\image-20210112155326118.png)

  

![image-20210112161531220](D:\Typora\ASC\image-20210112161531220.png)

简单选择排序													$\Theta(n^2)$															$\Theta(n^2)$

冒泡排序															$\Theta(n^2)$															$\Theta(n^2)$



### CH6 堆排序

* 排序算法的稳定性

* 堆排序：**O(nlgn)， 原址、不稳定**

* 二叉堆（是完全二叉树）：数据存放在数组中，但是可以假想为树的形式

* 注意 A.length 和 A.heapsize区别

* 函数：PARENT、LEFT、RIGHT函数

* 维护堆性质：**MAX-HEAPIFY(A,i)**

  * 先决条件：需要i节点为根节点的树的左右子树均为最大堆
  * 实现：递归向下：i节点与其左右儿子比大小

  * 结果：i节点为根节点的树也成为最大堆

  * 时间复杂度：**O(lgn)**(与树高h=$\lfloor lgn \rfloor$有关)

* 建堆：BUILD-MAX-HEAP(A) 时间复杂度为**O(n)** ，调用MAX-HEAPIFY(A,i)

* HEAPSORT(A):时间复杂度**O(nlgn)** 

  * 先BUILD-MAX-HEAP(A) ，再A.length次交换出最大值，以及MAX-HEAPIFY(A,i)

* 基于堆实现优先队列

  以下时间复杂度均假设有n个元素

  * MAXIMUN(S):返回S中最大关键字的元素。

    对应函数HEAP-MAXIMUN(A), **$\Theta(1)$**时间

  * EXTRACT-MAX(S)：去掉并返回S中的具有最大关键字的元素

    对应函数HEAP-EXTRACT-MAX(A):**O(lgn)**时间

  * INCREASE-KEY(S,x,k):将元素x的关键字值增加到k(k>=x，否则为空操作)

    函数HEAP-INCREASE-KEY(S,x,k):注意需要维护大根堆，所以结点要不断和父节点比较，**O(lgn)**时间

  * INSERT(S,x)：x插入集合S中

    MAX-HEAP-INSERT(A,key):**O(lgn)**时间 ，调用INCREASE-KEY(S,x,k)即可

### CH7 快速排序

* **原址排序、不稳定**、最坏$\Theta(n^2)$, 期望$\Theta(nlgn)$

  排序大数组最常用

* 仍分治法思想

  分解、解决、合并(不需此步)

* 数组的划分PARTITION(A,p,r)是关键，详见书p95-96的图解,主元为A[r]，主要将数组划分为4个部分

  时间复杂度:$\Theta(n)$

* 快速排序的性能：

  * 快速排序运行时间依赖于划分是否平衡
  * 最坏：每次划分为n-1和0，此时$\Theta(n^2)$
  * 最好：可能的最平衡划分：每次划分$\lfloor n/2\rfloor$和$\lceil n/2\rceil-1$,此时$\Theta(nlgn)$
  * 平衡的划分：常数比例的划分时，总是$O(nlgn)$

* 快速排序的随机化版本

* 期望运行时间：未看，数学推导



### CH8 线性时间排序

* 最坏情况下，任何比较**排序算法**都要做$\Omega(nlgn)$次比较

  堆排序和归并排序都是渐进最优的比较排序算法

* 计数排序

  * n个输入元素，值均为[0,k]上一个整数；
  * 一般时间复杂度为$\Theta(k+n)$；k=O(n)时，排序时间复杂度$\Theta(n)$
  * 计数排序是稳定的(最后for循环是逆向的)

* 基数排序

  * n个d位数，每一个数位有k个可能取值，RADIX-Sort用的稳定排序方法耗时$\Theta(n+k)$,则其可以在$\Theta(d(n+k))$时间内排好序
  * 非原址
  * ![image-20210112182903016](D:\Typora\ASC\image-20210112182903016.png)

* 桶排序：假设数据服从均匀分布，则平均时间代价为O(n)

### CH9 中位数和顺序统计量

* 第i个顺序统计量(第i小的数)、中位数(下中位数)

* 找min或max: 最好即是n-1次比较

* 同时找到最小和最大：$\lceil \frac{3n}{2} \rceil -2$(不论奇偶)

  偶为 3n/2-2; 奇为3(n-1)/2

* 期望为线性时间的选择算法

  * RANDOMIZED-SELECT(A,p,r,i)算法，利用Random-partition来递归找出第i个顺序统计量
    * 最坏$\Theta(n^2)$; 期望$\Theta(n)$

* 最坏情况为线性时间的选择算法

  * 步骤：分为$\lfloor n/5\rfloor$组； 寻找插入排序寻找每一组的中位数； 递归调用SELECT找出中位数中的中位数a； 调用修改后的PARTITION按a作划分； 递归调用SELECT(分=><3种情况)
  * T(n)=O(n)

![image-20210113171936660](D:\Typora\ASC\image-20210113171936660.png)

### CH12 二叉搜索树

* 包含属性：key，left，right，p

  * 左子树关键字不超过根，右子树关键字不低于根
  * 中序遍历 ：按序输出树中key ，$\Theta(n)$, 递归式+代入法求解时间复杂度

* 高度为h的树，以下操作均需$O(h)$

  * 查找：TREE-SERACH(x,k)的递归和迭代版本p163

  * 最大关键字元素和最小关键字元素：一直往右/左走

    TREE-MINIMUM(x)，TREE-MAXIMUM(x)

  * 后继和前驱

    TREE-SUCCESSOR（x）：后继：书p164

    TREE-PREDECESSOR(x):前驱，ppt18

* 插入：TREE-INSERT(T,x)，O(h)， 一定是落到叶结点上

* 删除：O(h)，分情况讨论，四种情况：见书p166-p167

  1. z无孩子或只有右孩子 （即z无左孩子）
  2. z只有左孩子
  3. z有左右孩子且z的后继y为z的右孩子
  4. z有左右孩子且z的后继y不为z的右孩子（注意3，4里y一定无左孩子且在z的右子树中）

  * TREE-DELETE（T,z）,主函数
  * TRANSPLANT(t,u,v):用v来替换u这个结点(只是与u的双亲作了联系，并未动u，v的孩子)

* 1棵有n个不同关键字的随机构建二叉搜索树的期望高度为O(lgn)

* 二叉搜索树高度$h>=\lfloor lgn \rfloor$

* ppt补充：lec5 ipad 20-23

  * 二分检索：如折半查找、Fibonic查找(ppt22页补充笔记)
  * 二分检索的过程，可以用一个二叉树来表示，即二分检索树
  * 二分检索算法：ppt21。 变式：不是对半分情况
  * 判断一棵树是否是折半查找对应的二分检索树




### CH13 红黑树

思考：红黑树中从根节点到叶结点的最长路径所含边数不超过最短路径的2倍； 但红黑树根结点左右子树的高度差可能超过2倍![image-20210113111807104](D:\Typora\ASC\image-20210113111807104.png)

##### 13.1

* 树中结点属性：color,key,left,right,p

  把带关键字的结点视为树的内部结点

* 红黑性质：5条![image-20210113093427882](D:\Typora\ASC\image-20210113093427882.png)

* 哨兵结点T.nil

* 结点的黑高：bh(x)，不包括该结点![image-20210113093451122](D:\Typora\ASC\image-20210113093451122.png)

  红黑树的黑高为其根结点的黑高

* ![image-20210115122533798](D:\Typora\ASC\image-20210115122533798.png)

* TREE-SERACH(x,k)

  TREE-MINIMUM(x)，TREE-MAXIMUM(x)

  TREE-SUCCESSOR（x）：后继：书p164

  TREE-PREDECESSOR(x):前驱，ppt18

  以上算法可在红黑树上O(lgn)时间内运行，代码同12章

##### 13.2

* 基于x左旋：x变为其右孩子的左儿子
* 基于y右旋：y变为其左孩子的右儿子
* 均O(1)

##### 13.3 

* RB-INSERT(T,z): 像普通二叉搜索树那样插入一个结点z，并把它着红色，左右改为T.nil

* RB-INSERT-FIXUP(T,z)：对结点重新着色并旋转

  while循环为看z父亲==红是否满足

  对照代码理解书上所讲的三种case以及循环不变式的保持

  以下为z父亲为左儿子时

  * case 1:  z的叔为红色：z上一层全变黑，z的爷爷变红，z=z.p.p
  * case 2:  z的叔为黑色且z为右孩子:对z=z.p， 对z作左旋 变为case3
  * case 3:  z的叔为黑色且z为左孩子 : z父亲改为黑色，爷爷改为红色，对z.p.p作右旋

  对称情况则是所有right和left调换

  总而言之，循环只在case 1时反复，一旦进入case 2或case 3，则执行完当次循环后循环结束， 旋转操作最多做两次

* 时间: O(lgn)

##### 13.4

* RB-TRANSPLANT(T,u,v)

  与12章差不多，主要区别在于NIL的不同

* RB-DELETE(T,z)

  与12章差不多，主要区别在于

  * 结点y的维护

    * y初始颜色的存储
    * y始终为从树中删除的结点(第一行)或移动至树内的结点(第9行)

  * 结点x的维护

    * x始终指向y的唯一子节点或指向哨兵T.nil（当y无子节点时）

      其赋值语句在第4，7，11行，可参考纸质书p184和p167笔记

      且需要注意到，当处于p167的c，d两种情况时，可根据y的颜色来显而易见的看出x是不是T.NIL（y为红色时，一定是；y为黑色时，x若为黑色则一定是；但也可x为红色，不过此时调用RB-DELETE-FIXUP(T,x)循环都不用进去就可以修正了）

* RB-DELETE-FIXUP(T,x)

  主要四种情况分类理清楚即可，参考ppt99页的实例

  四种case的运行情况参考ipad书p185页

  以下为x为左儿子时：

  * case1： x兄弟w为红 ， x.p变红

    * w变黑，再对x.p左旋

  * case2 ： x兄弟w为黑，且w的两儿子都黑  

    *  w变红，x=x.p(即脱了一层黑到父亲结点)

  * case3： x兄弟w为黑，且 w的左孩子为红，右孩子为黑 

    * w变红，w左孩子变黑，对w右旋

  * case4： x兄弟w为黑，且 w右孩子为红

    * w颜色变为w.p颜色， w.p变为黑色， w右孩子变黑色，对w.p左旋

  * case1 最多进一次，一旦进入后，无论之后走case 2 还是 case 3/4,都会退出循环

    直接case 2，有循环

    一旦进入case3 或4，则必退出循环

* 时间复杂度O(lgn)



### CH14 数据结构的扩张

##### 14.1

* 修改红黑树，使得O(lgn)内确定任何顺序统计量
* 顺序统计树：新增属性x.size（以x为根的子树(含x)的内结点数），哨兵结点此值为0
* 秩：集合线性序中的位置：即中序遍历树时输出的位置
* 查找具有给定秩的元素
  * OS-SELECT(x,i)， 根据x的左结点的size属性确定x的秩，再与i比较后去左/右子树递归调用
  * O(lgn）
* 确定一个元素的秩
  * OS-RANK(T,x)：首先求以x为根的子树上x的秩，然后不断上升到根，每当x为右儿子时，其秩会被其兄弟结点的size+1所推后
  * O(lgn）

* 对子树规模的维护
  * 插入操作insert 要自上而下增加路径上每个结点的size (也可以再fix_up调用前逐层往上更新size)，fix_up里不用
  * 删除操作delete则在fix_up调用前，从x.p开始逐层往上更新size，  fix_up不用
  * 左旋右旋的代码末尾需要更新x,y的size属性

##### 14.2

* 扩张数据结构四步
  * 选择一种基础数据结构
  * 确定基础数据结构中要维护的附加信息(如x.size，当然也可以是指针类信息而非具体数据)
  * 检验基础数据结构上的基本修改操作能否维护附加信息
  * 设计一些新操作
* ![image-20210113121428538](D:\Typora\ASC\image-20210113121428538.png)

##### 14.3 

* 区间树：区间三分律、区间重叠

* 关键字:x.interval.low

* 附加信息：x.max（以x为根的子树（含x）的所有区间的端点的最大值）

* 维护：利用定理14.1可知成立，且更改的方式与函数位置同14.1

  * INTERVAL-INSERT(T,x)
  * INTERVAL-DELETE(T,x)

* 支持的操作

  * INTERVAL-SEARCH(T,i)：O(lgn)

    从根开始while循环，当该结点与i不重叠，则判断往左还是往右![image-20210113123657542](D:\Typora\ASC\image-20210113123657542.png)



### CH15 动态规划

* 适用于动态规划求解的问题的两个关键特征

  * 最优子结构（书p206）

    最优子结构性质：问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解

    （全局最优，一定局部最优）

  * 子问题重叠：不同子问题具有公共的子子问题

* 对比：分治法是划分为互不相交的子问题

* 常用来求解最优化问题

* 设计动态规划算法的4个步骤

  1. 刻画一个最优解的结构特征(此步最难、最关键，即要确定最优子结构)
  2. 递归地定义最优解的值(写出递归式)
  3. 计算最优解的值，通常采用自底向上的方法
  4. 利用计算出的信息构造一个最优解(此时需在第3步里维护一些额外信息)

##### 钢条切割

* 递归式![image-20210113153421023](D:\Typora\ASC\image-20210113153421023.png)

* 自顶向下递归实现：CUT-ROD(p,n)， 运行时间$T(n)=2^n$

* 动态规划的两种实现方法：$\Theta(n^2)$

  * 带备忘的自顶向下法

    MEMOIZED-CUT-ROD(p,n)

    MEMOIZED-CUT-ROD-AUX(p,n,r)

    运行时间分析：每个规模的子问题只求解一次，其他均相当于查表，所以算法运行时间等于每个子问题求解时间之和。

  * 自底向上法（比前者的时间复杂性函数有更小的系数）

    BOTTOM-UP-CUT-ROD(p,n)， 本质是开一个数组，从小问题开始求并把值保存

* 重构解：求解规模为j的子问题时将第一段钢条的最优切割长度i保存在s[j]中

##### 矩阵链乘法

* ![image-20210113161345537](D:\Typora\ASC\image-20210113161345537.png)
* 利用s[i,j]输出乘法括号
* ![image-20210115114029143](D:\Typora\ASC\image-20210115114029143.png)
* $\Theta(n^3)$

##### 动态规划原理

* 无权最短路径问题：有最优子结构

  无权最长路径问题：无最优子结构

  两者区别在于：子问题是否相关（最短路径里不相关）

  子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解

* 若子问题空间中某些子问题完全不必求解，则备忘方法更优，因为它只会求解那些绝对必要的子问题

##### 最长公共子序列(LCS)问题

* 前缀
* 最优子结构 -> 一个递归解![image-20210113171116974](D:\Typora\ASC\image-20210113171116974.png)

* 算法LCS-LENGTH(X,Y):  (X:m项，Y:n项)

  * c[i,j]存$X_i,Y_j$的LCS长度
  * b[i,j]存表项对应所选择的子问题最优解，用带方向的箭头表示
  * 算法按行主次序计算（c[1,..], c[2，...]以此类推 ）
  * 时间:$\Theta(mn)$
  * 图15-8:例子
* 算法改进

  * 去掉表b：但表c仍需$\Theta(mn)$空间
  * 若只需计算LCS的长度，而不需重构该序列，则只用一行多一点的空间即可

##### 最优二叉搜索树

* 最优二叉搜索树问题：n个关键字ki(已排序，为内部结点)、n+1个伪关键字di(叶结点)，各有一个搜索频率pi/qi

* 目标：构造期望搜索代价最小的二叉搜索树

* ![image-20210113173823463](D:\Typora\ASC\image-20210113173823463.png)

* ![image-20210113174826022](D:\Typora\ASC\image-20210113174826022.png)

  ![image-20210113174845674](D:\Typora\ASC\image-20210113174845674.png)

* root[i,j]保存根节点$k_r$下标

* ![image-20210113175202786](D:\Typora\ASC\image-20210113175202786.png)

* 注意与矩阵链乘法的相似处，以及相异处(e,w，root矩阵的下标与 m，s矩阵的下标对比)

  ![image-20210115114143610](D:\Typora\ASC\image-20210115114143610.png)

### CH16 贪心算法

##### 活动选择问题

* 活动、兼容、开始时间、结束时间
* 活动已按结束时间单调递增排序
* 活动选择问题的最优子结构

  * $S_{ij}:a_i结束后开始，且在a_j开始前结束的活动集合$
* 贪心选择

  * $S_k:在a_k结束后开始的任务集合$
  * 定理16.1：考虑任意非空子问题$S_k$,令$a_m是S_k$中结束时间最早的活动，则$a_m$在$S_k$的某个最大兼容活动子集中
  * 定理16.1+最优子结构  可以说明贪心选择能得到最优解
* 递归贪心算法
  * 结束时间相同的活动可以任意排列（此时作贪心选择也可任选其一）
  * 虚拟活动$a_0$
  * RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n)
  * 变式：考虑问题按开始时间从小到大排序，则每次贪心选择开始时间最晚的那个活动->与书上所讲原理、证明一致
  * 运行时间$\Theta(n)$,不过若活动未排序，则排序还需$O(nlgn)$
* 迭代贪心算法
  * 尾递归 容易转化为迭代形式
  * GREEDY-ACTIVITY-SELECTOR(s,f)
  * $\Theta(n)$

##### 贪心算法原理

* 贪心选择性质：通过作出局部最优选择来构造全局最优解

  * 需证明每个步骤做出贪心选择能生成全局最优解
  * 多考虑对输入进行预处理或合适的数据结构来提高贪心选择的效率

* 最优子结构

  * 一个问题的最优解包含其子问题的最优解
  * 主要需证明将子问题的最优解与贪心选择组合在一起就能生成原问题的最优解

* **0/1背包问题：动态规划**

  **分数背包问题：贪心算法**

  **还要看看**

##### 赫夫曼编码

* 文件的最优编码方案总是对应一棵满二叉树，即每个非叶节点都有两个孩子节点，此时若有n个叶节点，则一定有n-1个内部结点

* 编码文件的代价B(T)![image-20210113203155809](D:\Typora\ASC\image-20210113203155809.png)

* 构造赫夫曼编码

  * 利用优先队列：见第六章

    其只是一种定义，而第六章是用堆来实现优先队列

  * HUFFMAN编码不唯一，比如每次取的最小两个结点x,y,谁作为左子树都可以，代价相同，但编码不同

  * 运行时间$O(nlgn)$

* 赫夫曼算法的正确性

  需证明最优前缀码问题具有贪心选择和最优子结构性质

  参见16.2节**一般设计方法**一栏

  * 引理16.2解决了：

    * 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解(子问题即引理16.3中所述的字母表C'的编码树求解)
    * 证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的

  * 引理16.3解决了：

    证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构

* 补充：k进制编码则需要求解E(加权外部路径长度 ，即前面的B(T))最小的k叉树

  * 特例：Huffman编码(二进制码)为E最小的二叉树

  * 一般而言，需要满足 (k-1)|(n-1)，（n为字符个数，k为进制，即n-1能被k-1整除），若不满足此要求，需添加虚拟节点(权值为0)

    此时，只需每次取权值最小的k个结点来合并即可

### CH17 摊还分析

* 保证最坏情况下每个操作的平均性能

* 例子：栈操作（Multipop）、二进制计数器递增 -》分析出来总摊还代价都是O(n)

* 聚合分析：求操作序列的总代价，然后平均代价作为每个操作的摊还代价

* 核算法：每个特定操作摊还代价可能不同-> 信用(存入或用掉)+实际代价

  需保证任意n个操作序列的总摊还代价是总实际代价的上界

* 势能法：从$D_0$起，，每执行一个操作会得到下一个状态$D_1$, 各自对应一个势![image-20210113213015700](D:\Typora\ASC\image-20210113213015700.png)



### CH19 斐波那契堆

* ![image-20210113215544309](D:\Typora\ASC\image-20210113215544309.png)

##### 斐波那契堆结构

* 可合并堆：支持5种特定操作
* 斐波那契堆是一系列具有最小堆性质的有根树集合
* 指针：p,child,left,right,即兄弟节点间为环形的双向链表，称为他们父结点的孩子链表。都有指向父结点的指针，每个结点只能指向其某一个孩子
* 环形双向链表的好处：书p292第二段
* 特殊值：x.degree(孩子数目), x.mark
* 最小结点：H.min(多个最小取任意一个，空则为NIL)
* 根链表也是环形双向链表
* H.n ：H中当前结点数目
* 势函数：![image-20210113220307570](D:\Typora\ASC\image-20210113220307570.png)
* 在一个n个结点的斐波那契堆中任何结点的最大度数的上界D(n)， 本章里D(n)=O(lgn)

##### 可合并堆操作

* MAKE-HEAP():创建和返回一个新的不含任何元素的堆 ，O(1)

* INSERT(H,x),  插到根list中 ，O(1)

* MINIMUN(H), 寻找最小结点，O(1)

* EXTRACT-MIN(H)：摊还代价O(D(n))

  把最小节点z的每个孩子加入根list，然后删去z，最后调用Consolidate把有相同度数的根结点合并，直到每个度数至多只有一个根在根链表

  * 主函数FIB-HEAP-EXTRACT-MIN(H)

  * 合并H的根链表：调用CONSOLIDATE(H)

    * 两步走：以for+while循环不断反复

      * 找根链表中两个有相同度数的根x，y( y.key>=x.key)

      利用一个辅助数组A[0..D(H.n)]来记录是否已经找到一个度数为i的结点(A[i])

      * 把y链接到x。调用FIB-HEAP-LINK(H,y,x)，把y从根链表删除，并使y成为x的孩子，y.mark=False ,x.degree++

    * 最后再处理根链表，设置H.min

    * ![image-20210113222737835](D:\Typora\ASC\image-20210113222737835.png)

* UNION($H_1,H_2$)， O(1)，只是把两个堆的根list合在一起

##### 关键字减值和删除一个结点

* 减值：O(1)
  * FIB-HEAP-DECREASE-KEY(H,x,k)：改变x.key的值，当x为根结点或者x.key仍比其父结点key大时，未违背性质，不用变，否则调用CUT和Cascading-cut
    * 子函数CUT(H,x,y):把x移到root list，x.p=NIL, x.mark=False
    * 子函数CASCADING-CUT(H,y): 级联切断，若一个非根结点失去了两个孩子，那么会被移到root list
    * 势的分析
  * 上一节的所有操作中，只有insert和fib-heap-link里有设置mark=False的情况
* 删除：O(D(n))， 调用decrease-key和extract-min

##### 最大度数的界

* ![image-20210113235104872](D:\Typora\ASC\image-20210113235104872.png)





### CH21 用于不相交集合的数据结构

* 三个函数 ：MAKE-SET(x),  UNION(x,y),  FIND-SET(x)， 参数均为指针

* 分析运行时间的2个参数 ： n(MAKE-SET操作次数)，m（三个操作总次数）

* 一个应用：确定无向图的连通分量

  * CONNECTED-COMPONENTS(G)
  * SAME-COMPONENT(u,v)
  * 在具体实现中，图和不相交集的数据结构的表示需要互相引用

* 不相交集合的链表表示

  * 每个集合为一个链表，有head和tail指针。 链表中每个对象包含一个集合成员，一个next指针，一个返回到集合的指针。 代表为head所指节点

  * MAKE-SET(x),  FIND-SET(x) 均只要O(1)

  * UNION(x,y)：简单拼接，则与y的链表长度成线性关系

    所以能很容易得到一个$\Theta(n^2)$的操作序列

  * 加权合并启发式策略：每次把短链表作为y

    需维护表的长度

    m个操作序列共需$O(m+nlgn)$时间( 定理21.1)

* 不相交集合森林

  * 每个集合用一棵树表示，树根为代表，每个节点有x.p, x.rank
  * 按秩合并、路径压缩来改进运行时间, 最坏为$O(m\alpha(n))$



### CH22 基本的图算法

本节对有向、无向图均可

* 针对无向图和有向图，均有两种表示：
  * 邻接链表（表示稀疏图时有优势）
    * 存储空间$\Theta(V+E)$
    * 可修改后表示权重图，即每条边有其权重
    * 缺陷：无法快速判断一条边（u,v）是否是图中的一条边：需顺序查找adj[u]的链表
  * 邻接矩阵（稠密图优势）
    * 可快速判断任意两个结点间是否有边相连
    * 无向图里是对称矩阵

##### 广度优先搜索(BFS)

* Prim、Dijkstra的算法的起始

* 能计算源到每个可到达结点距离最少的边数，并生成广度优先搜索树
* 无向图/有向图都适用
* 颜色定义

  * 白色：未入队
  * 灰色：队列中
  * 黑色：已出队并探索完其邻接链表
* 每个结点维护的三个属性：$color,\pi, d$
* 流程：初始根s入优先队列。然后while循环，出队一个元素，找其为白色的邻接点依次入栈置为灰色，再反复循环 
* 算法:BFS(G,s), 复杂度$O(V+E)$， 用邻接矩阵则为$O(V^2)$

* ![image-20210114100312800](D:\Typora\ASC\image-20210114100312800.png)
* 广度优先树：

  * 图G的前驱子图$G_{\pi}$是一棵广度优先树
  * 是连通的
  * $|E_{\pi}|=|V_{\pi}|-1$
  * $|E_{\pi}|$中的边称为树边
  * ![image-20210114100709392](D:\Typora\ASC\image-20210114100709392.png)

##### 深度优先搜索

* 深度优先森林、前驱子图

* ![image-20210114101054740](D:\Typora\ASC\image-20210114101054740.png)

* 属性：color, $\pi$, 时间戳d,f

* 流程：初始化所有结点——》遍历所有结点，若color为白，则DFS-VISIT

  * 在子函数里，time+1，赋值u.d,  然后遍历u的每个邻接点，依次递归调用DFS-VISIT。 最后time++, u.f=time表明u结点访问完毕
  * ![image-20210114101829028](D:\Typora\ASC\image-20210114101829028.png)

* 算法:DFS(G),DFS-VISIT(G,u) : 复杂度$\Theta(V+E)$， 用邻接矩阵则为$O(V^2)$

* 深度优先搜索的性质

  * ![image-20210114103040901](D:\Typora\ASC\image-20210114103040901.png)

  * 结点发现时间和完成时间有括号化结构

    括号化定理22.7:两个结点要么互相完全包含要么完全分离

    推论22.8：后代区间的嵌套

  * v是u的后代 <=> v在u为灰色的时间里被发现

  * **白色路径定理**：定理22.9![image-20210114103536533](D:\Typora\ASC\image-20210114103536533.png)

* 边的分类：树边、后向边(连到祖先，含自循环)、前向边(指向后代)、横向边

  * 无向图 不存在横向边、前向边
  * ![image-20210114104859522](D:\Typora\ASC\image-20210114104859522.png)

##### 拓扑排序

* 针对有向无环图

* TOPOLOGICAL-SORT(G): 结点次序与结点完成时间.f相反，后完成的(即.f值大的)在次序靠前处

  时间复杂度$\Theta(V+E)$

  ![image-20210114112136638](D:\Typora\ASC\image-20210114112136638.png)

* ![image-20210114112151068](D:\Typora\ASC\image-20210114112151068.png)

##### 强连通分量

* 图的转置$G^T=(V,E^T)$,  创建时间为$O(V+E)$

  与G的强连通分量完全相同

* STRONGLY-CONNECTED-COPONENTS(G)用两次DFS计算出G的强连通分量，$\Theta(V+E)$

  第二轮对$G^T$作DFS时，按第一轮DFS(G)的拓扑排序次序访问结点， 最后$G^T$的每个深度优先树即为一个强连通分量

* 分量图概念:是一个有向无环图，把G的强连通分量收缩为一个点的结果

* ![image-20210114114351215](D:\Typora\ASC\image-20210114114351215.png)

* ![image-20210114114253933](D:\Typora\ASC\image-20210114114253933.png)



### CH23 最小生成树

* 用到的数据结构：Prim/Kruskal+普通二叉堆O(E lgV) ;  Prim+斐波那契堆: O(E+V lgV)
* 贪心策略
* 都是针对**无向图**(有向图则无意义)

##### 最小生成树的形成

* 安全边
* 循环不变式：![image-20210114115424670](D:\Typora\ASC\image-20210114115424670.png)
* ![image-20210114120647246](D:\Typora\ASC\image-20210114120647246.png)
* ![image-20210114120753122](D:\Typora\ASC\image-20210114120753122.png)
* ![image-20210114120805272](D:\Typora\ASC\image-20210114120805272.png)

##### Kruskal算法

* 每次选择一条当前最小的边，且满足边的两端点不在一个集合里

  * 算法MST-KRUSKAL(G,w)

  * 运行时间依赖于不相交集合数据结构的实现方式

    O(ElgE)或**O(ElgV)**，按秩合并+路径压缩

* 原理利用定理23.1

##### Prim算法

* 原理利用推论23.2
* 流程即：每次从选出距离当前已找到的树最近的一个结点加入该树
* 最小优先队列Q的实现方式，主要用到V次Extract-min和E次decrese-key
  * 二叉堆：O(ElgV)
  * fibonacci堆：O(E+VlgV)



### CH24 单源最短路径

**都是针对带权重的有向图**

* 最短路径问题：路径权重、最短路径权重

* **单源最短路径问题：满足最优性原理；但在有负环时问题无定义**

* **单源简单最短路径问题：满足最优性原理；在有负环路时问题有定义，但不满足最优性原理**

* 若从源结点s可以到达权重为负的环路，则最短路径权重可能无定义

* 变体：单目的地最短路径问题、单结点对最短路径问题、所有结点对最短路径问题

* 最短路径的最优子结构：最短路径的子路径也是最短路径

* 在单源最短路径问题里，若不存在权重为负的环路，那么最短路径一般就只考虑简单路径(权重大于等于0的环路可以在路径中删去)

* 最短路径的表示：前驱结点、前驱子图

  * 最短路径树(有点类似于广度优先树)：包含的三个条件：书p376底部

    最短路径树可能不唯一

* 松弛操作：维持一个属性v.d,记录从源节点s到结点v的最短路径权重的上界，即最短路径估计
  * RELAX(u，v，w) ，根据u.d和w(u,v)来修改v.d和$v.\pi$
  * 这是唯一导致最短路径估计和前驱结点发生变化的操作
* 初始化：INITIALIZE-SINGLE-SOURCE(G,s)，  $\Theta(V)$
* ![image-20210114153722964](D:\Typora\ASC\image-20210114153722964.png)

##### 本章所有算法都以邻接链表实现

##### Bellman-Ford算法

* BELLMAN-FORD（G,w,s）：初始化；对每条边作|V|-1次relax；最后对每条边检查看是否有权值<0的环路
* 时间：$O(VE)$,若能按最佳顺序(DAG的拓扑排序次序)，则只需1趟，O(V)

##### 有向无环图中的单源最短路径问题

* DAG-SHORTEST-PATHS(G,w,s),只需拓扑排序后，按照该结点次序依次对其邻接链表上的点作relax
* 定理24.5：算法正确性证明
* $\Theta(V+E)$
* 算法应用：PERT图的关键路径分析

##### Dijkstra算法

* 要求所有边权重为非负

* ![image-20210114181008915](D:\Typora\ASC\image-20210114181008915.png)

  算法里有**V次extract-Min, E次decrese-key**

* 算法性能分析：依赖于最小优先队列的实现

  * 数组实现：$O(V^2)$  （每次extract-Min要O(V)）

  * 稀疏图时二叉堆实现：$O((V+E)lgV)$

    若所有结点都可从源节点到达(此时E>=V),则为$O(ElgV)$

  * 斐波那契堆：摊还代价$O(VlgV+E)$

* Dijkstra算法在有负环、或者无欢有负边时的错误例子![image-20210110180901571](D:\Typora\ASC\image-20210110180901571.png)

* 对任意权重非负的无向连通图，Dijkstra算法未必能得到该图一个最小生成树（不管如何选取源点s）



### CH25 所有结点对的最短路径问题

##### Johnson用邻接链表，其余用邻接矩阵

* 仍不含负环，但可以有负边
* V次Dijkstra算法
  * 线性数组 ：$O(V^3)+O(VE)=O(V^3)$
  * 二叉堆实现：$O(VElgV)$
  * 斐波那契堆：摊还代价$O(V^2lgV+VE)$
* 含有权重为负值的边：Bellman-Ford作N次
  * $O(V^2E)$
  * 若是稠密图:$O(V^4)$

* 算法输入：矩阵W；   输出：矩阵D

* ![image-20210114183333518](D:\Typora\ASC\image-20210114183333518.png)

##### 最短路径和矩阵乘法

* 最短路径的结构
* 所有结点对最短路径问题的递归解
* 自底向上计算最短路径权重
* 改进算法的运行时间：重复平方技术
* $\Theta(V^4)   ---->>>   \Theta(V^3 lgV)$

##### Floyd-Warshall算法

* $\Theta(V^3)$

* 最短路径的结构：从结点编号入手切分子问题

* ![image-20210114202729979](D:\Typora\ASC\image-20210114202729979.png)

  k表示路径的中间结点（不含端点）的编号不超过k

  ![image-20210114203010651](D:\Typora\ASC\image-20210114203010651.png)

  前驱矩阵![image-20210114203402974](D:\Typora\ASC\image-20210114203402974.png)

  ![image-20210114203413258](D:\Typora\ASC\image-20210114203413258.png)

* 有向图传递闭包的计算方式，只需要判断i到j是否有路径

  * 法1：每条边赋权重为1，运行floyd-warshall，若$d_{ij}<n$，则有路径，否则为无穷

  * 法二：逻辑操作节省时间空间，但仍为$\Theta(V^3)$![image-20210114204301411](D:\Typora\ASC\image-20210114204301411.png)

##### 用于稀疏图的Johnson算法

* 时间复杂度$ O(V^2lgV+VE)$(fibonacci)或$O(VElgV)$(二叉最小堆)
* 思路：重新赋予权重![image-20210114211521903](D:\Typora\ASC\image-20210114211521903.png)
  * 具体思路：以新结点s作一次bellman-ford,看有无负环路
  * 若无，令$\delta(s,v)=h(v)$，重新设置边权重
  * 然后对每个调用dijkstra算法![image-20210114212158473](D:\Typora\ASC\image-20210114212158473.png)



### CH30 多项式与快速傅里叶变换

* 次数界：n * n 次数界-> 2n-1的次数界![image-20210114213639819](D:\Typora\ASC\image-20210114213639819.png) 

* ![image-20210114214434233](D:\Typora\ASC\image-20210114214434233.png)

* 只需$\Theta(nlgn)$
* 注意添加系数为0的高阶系数来调整次数界和n的值
* 步骤：加倍次数界、 求值、 逐点相乘、 插值
* ![image-20210114220837132](D:\Typora\ASC\image-20210114220837132.png)
* ![image-20210114220900499](D:\Typora\ASC\image-20210114220900499.png)

### CH32 字符串匹配

* ![image-20210114223854923](D:\Typora\ASC\image-20210114223854923.png)

##### Rabin-Karp算法

* 预处理时间$\Theta(m)$ , 运行时间$\Theta((n-m+1)m)$，运行时间有期望O(n+m)或O(n)

  模式 长为m， 文本长为n

* 思路：为每个长为m的串 赋一个值， 当$f(P)=f(T_m)$是算是1次成功匹配

  快速计算：式32.1

* 改进（防止数字过大）：取模运算，式32.2

  * 书p581 图c算例
  * 伪命中点
  * 书p582算法：基数d、素数p的选取

##### 利用有限自动机进行字符串匹配

* 有限自动机的5元组定义：状态集、初始状态、接受状态、输入字母表、转移函数$\delta$

* 终态函数$\phi$ ：不用管

* 字符串匹配自动机

  * $\sigma$ ：后缀函数 ，定义及计算：书p584![image-20210114234637745](D:\Typora\ASC\image-20210114234637745.png)s

  * 转换函数图见p585， 状态数为m+1 (P的串长为m)，0为初态，m为末态，状态的数字代表已经匹配了$P_k$

    例子参见ipad书585![image-20210114234648868](D:\Typora\ASC\image-20210114234648868.png)

* 预处理时间$O(m| \sum^{}_{}|)$，  运行时间（匹配时间）$\Theta(n)$

* 引理：32.2， 32.3

* 计算转移函数：算法见p587， 复杂度 $O(m^3| \sum^{}_{}|)$

  可改进到预处理时间为$O(m| \sum^{}_{}|)$

##### KMP算法

* 匹配时间$\Theta(n)$,  预处理时间$\Theta(m)$

* 辅助函数$\pi$![image-20210115095209311](D:\Typora\ASC\image-20210115095209311.png)

* 模式的前缀函数:用于计算P要左移多少才能和当前已匹配到的$P_k$最大程度上再次匹配

  书p588 图32-10例子

* 两个算法见书p590，注意两个算法思路的一致性



### 补充

* 树的知识

  * **完全二叉树**：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树

    * 高度：结点到叶结点的最长简单路径上边的数目

      树高h=$\lfloor lgn \rfloor$

      与深度是反过来的。

    * 层数：高度+1

    * 具有n个节点的完全二叉树的深度为 k=$\lfloor lgn \rfloor$

      结点的深度：从根节点开始，深度为0，依次往下

      树的深度：叶结点深度

  * **严格二进制树：**每个节点正好有0或2个孩子

  * 满二叉树：国内与国外定义不同：https://blog.csdn.net/threadrunner/article/details/8739847

    国外的满二叉树是指国内的严格二进制树

  * ![image-20210112181006002](D:\Typora\ASC\image-20210112181006002.png)