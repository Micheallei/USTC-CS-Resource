## 报告记录与问题回答

### **听** 

* 曾建江老师的报告[AIoT时代的编程语言、编译器与指令集架构](https://b23.tv/z5cziy)；

### **写** -讨论的问题及涉及的编译知识要点

#### 趋势与挑战

* 微处理器的发展趋势![image-20201129210222727](D:\Typora\photos\image-20201129210222727.png)
  * 晶体管数量--摩尔定律（黄线）
  * 单核趋势（蓝线），近年开始发展缓慢
  * 频率：更早就走缓，受工艺限制
  * 能耗(黑线)：芯片能耗散的功耗已经达到了极限
* 通用计算的时代结束，进入异构计算时代
  * 处理器越来越专用、定制化
  * 对计算的并行、访存特征这个模式来定制硬件：eg：AI处理器

* 指令集发展
  * 通用CPU指令集架构的多样化和融合统一趋势
    * CISC指令集有RISC指令集互相的借鉴
    * 指令组合概念的引入
  * 指令集例子：CISC，RISC，VLIW（超长指令集）
  * 这些年发展下来，指令集架构种类的构想很多，但是目前现存商用的指令集数目少，趋于稳定
* 编译器与各种指令集架构之间发展的演进路径![image-20201129211253597](D:\Typora\photos\image-20201129211253597.png)
  * 单核优化
  * 多核优化
  * 异构优化:多核CPU已经不再是原来的通用CPU了，更转向了GPU、专用AI处理器、DSP、FPGA等，不同架构的核如何协同工作的问题。
* 后摩尔时代![image-20201129211704044](D:\Typora\photos\image-20201129211704044.png)
  * 既懂上层应用算法，又懂底层硬件模型，才能写出高质量代码，充分利用计算资源。
  * TPU：谷歌推出，针对领域定制的体系结构
  * XPU概念
  * 兼容性：
    * 二进制兼容性(太难)：直接可执行二进制文件在各个平台运行
    * 源代码兼容性(有挑战)：如英伟达GPU可通过opencl实现在不同GPU上开发。但是性能兼容性没法保证，而且软件移植成本高。
  * opencl
* 如何进行超异构时代的软件开发![image-20201129212331813](D:\Typora\photos\image-20201129212331813.png)
  * 声明式开发：所见即所得的交互式编程(实时预览等)
  * 协同式开发：多人协作/端云协同编程
    * 考虑同时开发的效率以及可能的冲突
  * 智慧化开发：AI辅助编程/AI可视化编程(比单纯代码提示更进一步)
    * 代码补全
    * 代码性能评估：如auto-tuning编译技术

#### 产业案例

* ![image-20201129212930497](D:\Typora\photos\image-20201129212930497.png)
  * super kernel优化技术：二进制层面实现算子Kernel融合调度，减少TS调度kernel的开销
  * 并行编译、ccache优化：编译构建软件的时间降低，即提高开发效率(比如一个底层小改动，可能使得全部工程需要重新编译)
  * 算子编译优化和代码生成技术
  * 总结：编译解决的问题：性能问题、开发时间(效率)问题
* ![image-20201129213255224](D:\Typora\photos\image-20201129213255224.png)
  * 关键：通过编译技术提升软件性能

#### 技术案例互动分享

* ![image-20201129213533263](D:\Typora\photos\image-20201129213533263.png)

  * AI领域主要使用python而非c：python的表达能力更好，易描述计算、业务逻辑
  * 编译器实现的功能：让芯片看懂高层语言并执行

* ![image-20201129213821238](D:\Typora\photos\image-20201129213821238.png)

  * 编译基本过程见上图，目前课内已经讲到代码生成一块

  * 解释执行、编译执行及字节码虚拟机

    * 动态类型：在python中我们是不会声明所使用对象的确切类型的。所谓的python动态类型，就是在程序运行的过程中自动决定对象的类型。

    * 编译执行：生成可执行文件(二进制格式)，性能好，速度最快

    * 解释执行：性能差，效率不高

    * 字节码：java源码-》自定义字节码-》解释执行，在执行过程中用JIT即时编译方式，把热点代码编译成机器码在硬件上直接执行，效率更高

      java虚拟机：运行字节码的机器，而非模拟系统硬件资源的PC机

* ![image-20201129215150171](D:\Typora\photos\image-20201129215150171.png)

  * 特性

    * 跨平台：独立于架构、设备、OS
    * runtime engine
    * 编程语言支持：java和c，实现了共同IR

  * ![image-20201129215222068](D:\Typora\photos\image-20201129215222068.png)

    * Maple engine使得java和c有了统一中间表示，可以统一优化，消除了跨语言通信的计算开销

      同时使得静态编译直接生成二进制可执行文件成为可能，不再依靠java虚拟机

* ![image-20201129215748293](D:\Typora\photos\image-20201129215748293.png)

  * eg：循环展开(因为跳转对处理器有额外开销)，所以考虑线性复制代码

  * 静态编译策略往往固定且单一，无法很好适应不同平台以及用户使用习惯。

  * ![image-20201129220105751](D:\Typora\photos\image-20201129220105751.png)

    一次编译肯定不可能达到最优，所以是反复迭代优化

    * 把内部编译策略、需调整的参数传给Search driver
    * profiler通过运行信息、性能指标、执行效率、访存时延等信息综合评估当前得到的编译解的性能是否高效
    * 流程：source-》excutable(可执行文件)-》在平台上执行(红色)，得到当前性能 -》profiler评估当前性能是否高效 -》综合这些信息交给search driver，在参数空间里搜索进一步的优化-》一轮结束，开始下一轮

    * NP完全问题：只能找到相对优的解

* ![image-20201129220709495](D:\Typora\photos\image-20201129220709495.png)

  * 核心问题：**如何使用特定指令来对软件应用进行优化的案例**；**反之，通过具体场景的问题来驱动指令集的设计**
  * 数据库应用的例子
    * 自旋锁使用
    * 考虑引入双寄存器原子指令，某个线程的挂起不会引起其他线程的执行

* ![image-20201129221452222](D:\Typora\photos\image-20201129221452222.png)

  * 例子：无锁共享数据结构

#### 挑战课题

* ![image-20201129221933830](D:\Typora\photos\image-20201129221933830.png)
* ![image-20201129222210710](D:\Typora\photos\image-20201129222210710.png)
* ![image-20201129222519817](D:\Typora\photos\image-20201129222519817.png)
  * 研究出一个通用的统一异构编程框架及一系列技术支持，以充分挖掘硬件潜力。面向应用统一IR能提高开发效率，提高可移植性，更易复用。

### **思**

**程序语言和编译对现代业界的作用和影响**

* 程序语言对现代业界的作用和影响

  * 不同的程序语言有其不同的特性，对应也在业界有各自的使用范围，为业界各个领域的发展奠定基础
    * python适用于快速开发应用程序，易学习、上手容易。而且诸如numpy、pandas、sklearn、tensorflow等现成库对于张量矩阵等计算、神经网络、机器学习等算法、应用实现提供了极大便利，为业界各类人工智能、大数据相关行业的蓬勃发展奠定基础
    * java：健壮的大型软件
    * C++/C:效率高(机器码、直接操作内存)，偏底层，对于游戏开发，神经网络中算法的实现很适合。但安全性相对欠缺，C++比C好一些
    * Rust：主打安全性的底层编程语言。因为现代计算机对于应用、系统各个方面的安全性提出了更严格的要求。
  * 反过来，对应当前业界潮流人工智能领域，新型AI编程语言的设计的迫切性日益凸显，业界AI算法性能的提升，可以考虑从编程语言开始构建，面向AI算法(如稀疏矩阵编程、语言原生自动微分等)来设计语言特性，能更好的自顶向下提升性能。

* 编译对现代业界的作用和影响

  * 编译优化的技术越好，对程序的构建开销，更优代码生成都有很大帮助。同时编译器的优化也能让流水线技术、多核并行利用更加充分，大大提高软件性能

  * 大数据时代，算力的提升、硬件资源的充分利用，成为业界产业化应用突破的关键。在超异构优化的层面，只有编译器能更好的处理DSA编译。在DSA面向特定场景设计软硬件系统的基础上，只有编译器也能面向特定场景优化，才能达到更好的性能。

  * 同时，大量涌现的AI专用处理器也使得完全手工开发AI芯片编译器不太现实。所以有了深度学习编译技术等研究，实现编译优化的自动化。比如TVM、讲座里提到的的auto-tuning编译技术，在很多方面，机器无限的算力(在搜索空间里寻找相对优的编译参数)往往比人有限的精力完成更出色的编译任务。

    当然，AI芯片与编译器的协同设计。自动编译和人工优化的结合仍然也是当前的业界的重要方向。

  * 统一IR与静态编译：若能对不同语言提供公共统一的IR，无疑能更好的处理多核与异构背景下整体算力的充分利用。探索方便易用的异构编程框架及其编译优化技术与运行时支持，能够极大提高业界应用开发效率，而且易于模块化，对于每个部分的优化能做到更精细，也可针对不同语言、不同场景自适应自组合，提高可移植性，更易复用。已有的LLVM IR也就是这样的成功案例，但是目前业界更要考虑的是异构环境下的统一IR。方舟编译器里maple编译执行时便实现了java和c的统一中间表示，为性能提升做出极大贡献。

### **问** 

**抛出至少2个现存编程语言及编译中的问题，以及至少1个对在研或未来编程语言与编译的问题**

- 在研或未来：
  - 超异构计算时代，GPU、专业AI处理器的出现，如何在编译器层面对不同类型的多核协同工作做出优化。
  - 声明式开发(所见即所得的交互式编程)中UI开发机制与编译的联系？如何实现实时浏览？
  - 智能化编程的挑战：如何在编译器层面实现代码补全及优化？
  - auto-tuning编译这样的深度学习编译与传统编译技术各自的优劣与应用场景？
- 现存：
  - 报告里所讲的java字节码之外的Jit即时编译的原理探究与实践
  - webAssembly如何来对C、Rust做编译从而运行到浏览器端？
  - 并行编译面临什么样的挑战：该怎么样来设计编程语言，才能更充分的利用并行编译的技术，进而提高编译构建的性能？
  - java如何实现全静态化编译技术：比如一个for循环，参数N需用户输入，那该如何来做全静态化编译？
  - python表达能力好，更易描述计算，业务逻辑，而与java类似的，它基于字节码解释执行，效率低下。那么python可否考虑类似于Jit即时编译为机器码来提升效率，减少解释执行里的重复工作？

### **做** 

**给出对你抛出的现存编程语言及编译问题的解答（包含编程与编译分析）、以及你对在研或未来编程语言及编译问题的思考。**

#### java里的Jit即时编译原理探究与实践

##### 实验环境

windows10 64bit

![image-20201130040343026](D:\Typora\photos\image-20201130040343026.png)

* 听完讲座后对这种即时编译的实现感到困惑，所以调研了一些资料并自己动手实践解开困惑。

* 通常Java程序最初都是被编译为字节码，通过解释器进行解释执行，解释执行能够获得更好的启动时间。某些被频繁执行的方法或者代码块，会被JVM认定为“**热点代码**”。在运行时JVM会把这些热点代码编译成与本地平台相关的机器码，并且进行各种层次的优化，以提高执行效率。完成这个任务的编译器称为即时编译器（JIT编译器）。

* 工作原理![image-20201130014530582](D:\Typora\photos\image-20201130014530582.png)

  当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。

  即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。

* 热点代码的判定：JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。

* JVM中集成了两种编译器

  * C1编译器
    * 启动速度快，但性能相对差，更偏向局部优化
    * 对应参数-client
  * C2编译器
    * 关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上
    * 对应参数-server
  * 无论是-client还是-server，C1和C2都是有参与编译工作的。这种方式成为混合模式（mixed），也是默认的方式

* 首先考虑对一段代码分别完全解释执行和完全编译执行

  * 通过-Xint参数强行指定只使用解释模式
  * 通过参数-Xcomp强行指定只使用编译模式，此时程序启动后就会直接对所有代码进行编译，这种方式会拖慢启动时间，但启动后由于省去了解释执行和C1、C2的编译时间，代码执行效率会提升很多

  ```java
  import java.util.Random;
  
  public class ma {
  	private static Random random = new Random();
  
  	public static void main(String[] args) {
  		long start = System.currentTimeMillis();
  		int count = 0;
  		int i = 0;
  		while (i++ < 99999999) {
  			count += plus();
  		}
  		System.out.println("time cost : " + (System.currentTimeMillis() - start) + " ms");
  	}
  
  	private static int plus() {
  		return random.nextInt(10);
  	}
  }
  ```

  ![image-20201130031733859](D:\Typora\photos\image-20201130031733859.png)

  * 可以看到，完全解释执行下(-Xint)，运行时间最慢
  * 而完全编译执行(-Xcomp)下，与正常的混合模式区别不大，原因主要在于正常混合模式采用即时编译，主要针对plus()方法调用做了即时编译，其他仍解释执行，这样相比于完全编译执行时编译的开销，即时编译耗时反而更少

* 再对上述代码作一个即时编译触发机制的探究(while循环数改为15000)

  * 即时编译器触发的根据有两个方面：

    - 方法的调用次数
    - 循环回边的执行次数

    JVM在调用一个方法时，会在计数器上+1，如果方法里面有循环体，每次循环，计数器也会+1。

  * 尝试根据方法调用触发：

    * 执行命令`java -XX:+PrintCompilation -XX:-TieredCompilation ma` （print参数是为了打印编译信息）

      ![image-20201130032902378](D:\Typora\photos\image-20201130032902378.png)

      如图最后一行，plus方法被编译为机器码存入codeCache

    * 执行命令`java -XX:+PrintCompilation -XX:-TieredCompilation  -XX:CompileThreshold=20000  ma`来限制即时编译的启动，仅当计数器超过20000才即时编译

      ![image-20201130033140223](D:\Typora\photos\image-20201130033140223.png)

      由图可以发现，这一次并没有plus方法的编译信息

#### 以Rust+WebAssembly为例，探究底层编程语言与JavaScript互调在Web应用里的实现

##### 实验环境：

```
windows 10 64bit
npm:6.14.5
cargo 1.41.0
chrome 版本 86.0.4240.111
```

* 因为上一学期在分布式文件系统及rust上的一些工作而了解到了这种实现的可能性，在此次任务里对此做了一定尝试与实践。

* WebAssembly工作原理：wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新二进制格式。

  编译器的“前端”将高级编程语言转换为IR。编译器的“后端”将 IR 转换成目标机器的代码，而WebAssembly便是运行在web上的目标机器代码

  ![image-20201130042800893](D:\Typora\photos\image-20201130042800893.png)

* ##### WebAssembly 比 JavaScript 执行更快的原因

  - 文件加载 : WebAssembly 文件体积更小，所以下载速度更快。
  - 解析阶段 : WebAssembly 的解码时间比 JavaScript 的解析时间更短;
  - 编译和优化阶段 : WebAssembly编译和优化所需的时间较少，因为在将文件推送到服务器之前已经进行了更多优化，且WebAssembly 的代码更接近机器码，而JavaScript 需要先通过服务器端进行代码优化，为动态类型多次编译代码。
  - 重新优化阶段 : WebAssembly 不会发生重优化现象，因为编译器有足够的信息可以在第一次运行时获得正确的代码，而 JS 引擎的优化假设则可能会发生“抛弃优化代码<->重优化”现象。
  - 执行阶段 : WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。
  - 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。

  * 执行：可以更快地执行，WebAssembly 指令更接近机器码

* 考虑到WebAssembly的速度优势，所以若能用底层语言编译到wasm格式来实现在浏览器端的web应用的部分功能，那么对于web应用的性能会有很大提升，特别是计算密集型任务如分布式计算、分布式文件系统等项目。当然，javascript体系十分成熟强大，仅通过Rust编译为WebAssembly来完全替代JavaScript是不现实的，但这也为Rust与JavaScript通过WebAssembly实现互调提供了广阔的发展空间。在需要速度、性能的计算任务时上wasm，在DOM调用等功能实现上用javaScript现成框架，是很理想的一种选择。

* Rust+WebAssembly的使用

  * 可以使用 Rust std，可以使用 Rust 的大多数第三方库（部分涉及多线程的，可能会有一些问题。
  * 可以调用几乎任何 JS 侧声明的方法，也可以暴露方法给 JS 调用。
  * 可以和 JS 侧互相”传递“几乎任何的数据类型，包括但不限于基本的数字、字符串、对象、Dom对象等。
  * 可以直接在 Rust 侧“操作”Dom，甚至已经出现了 Rust 版本的 react

* 以下的具体实践操作流程及配置文件代码可参考官网给出的教程https://developer.mozilla.org/zh-CN/docs/WebAssembly/Rust_to_wasm

* 首先`cargo new --lib hello-wasm`构建rust包

  并修改`lib.rs`为：

  ```rust
  extern crate wasm_bindgen;
  
  use wasm_bindgen::prelude::*;
  
  #[wasm_bindgen]
  extern {
      pub fn alert(s: &str);
  }//rust想调用的外部函数
  
  #[wasm_bindgen]
  pub fn greet(name: &str) {
      alert(&format!("Hello, {}!", name));
  }//编写的能在javaScript中调用的Rust函数
  
  ```

  `wasm-pack` 使用 `wasm-bindgen`工具，提供一个连接 JavaScript 和 Rust 的桥。它允许 JavaScript 使用 string 调用 Rust API，或者调用一个 Rust function 去捕获 JavaScript 异常

* 修改配置文件`Cargo.toml`

* `wasm-pack build --scope mynpmusername`构建包并发布到npm，这里会做这样几件事：

  1. 将 Rust 代码编译成 WebAssembly。
  2. 在编译好的 WebAssembly 代码基础上运行 `wasm-bindgen`，生成一个 JavaScript 文件将 WebAssembly 文件包装成一个模块以便 npm 能够识别。
  3. 创建一个 `pkg` 文件夹并将 JavaScript 文件和生成的 WebAssembly 代码移到其中

* 需要一个index.html来在网页显示内容

  ```html
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8">
      <title>hello-wasm example</title>
    </head>
    <body>
      <script src="./index.js"></script>
    </body>
  </html>
  ```

* index.js：其中引用的hello_wasm.js即是封装好的wasm接口

  ```javascript
  const js = import("./node_modules/@yournpmusername/hello-wasm/hello_wasm.js");
  js.then(js => {
    js.greet("WebAssembly");
  });
  ```

* 最后运行

  ```shell
  $ npm install
  $ npm run serve
  ```

* 结果：相当于javascript调用了rust里的greet函数，然后rust里的greet函数又调用了javascript的alert函数，最后在http://localhost:8080/能看到如下页面![image-20201130050212228](D:\Typora\photos\image-20201130050212228.png)

* 项目目录![image-20201130052956445](D:\Typora\photos\image-20201130052956445.png)

* 通过以上的实验我们可以体会到这种通过将C,Rust等编程语言编译为wasm并运行在web上的可行性，以及与JavaScript实现互调的可能性。而当下业界由于WebAssembly的出现，使得Rust的Web前后端框架也应运而生，也值得参考借鉴。

  

#### 对在研或未来编程语言及编译问题的思考

* 超异构计算时代，GPU、专业AI处理器的出现，如何在编译器层面对不同类型的多核协同工作做出优化？
  * 可能可以考虑统一化IR设计的发展，正如方舟编译器所做的将java、c实现为统一的IR，为其后续全程序优化，消除跨语言的通信的计算开销，以及跨过虚拟机直接静态编译，这样对性能的提升是有目共睹的。若能对不同语言提供一套在异构环境下的统一的IR标准，那么无疑能提高开发效率，增大优化空间，更方便的根据处理器特性对IR进行优化，从而能在整体上更好的利用机器资源。
  * 完全统一IR难度可能较高。那么退一步，我们可能可以考虑在某些特定应用领域内(如某一类人工智能应用)，从设计专用AI编程语言、编译器都统一标准，来实现小部分的IR统一。
  * 当然确实这样面向特定应用领域的设计往往效果好，但是可移植性差，所以需要在专精与适应不同场景的应用两个方面作一个权衡取舍。



### **惑** 

**给出你关于编程语言与编译的困惑或不明白的问题。**

* 深度学习编译技术里搜索空间要如何来设计，需要考量哪些因素，有何经验或技巧？
* Maple编译执行原理：全程序优化的实现以及静态编译的实现都依赖于java和C的统一IR，那么在设计这样的多语言统一IR的过程里需要考虑哪些因素？这是否也算是前面提出的统一异构编程框架的一种局部实现？
* 通用编程语言如何来更好的满足各种应用场景的定制需求？





### 参考文献

* https://zhuanlan.zhihu.com/p/65452090
* https://zhuanlan.zhihu.com/p/81941373
* https://developer.ibm.com/zh/languages/java/articles/j-lo-just-in-time/







评语：

* 报告整体完成度 不太理想，比如”思“这一块过于泛泛而谈。
* 做的部分抛出的问题很好，但建议可以实际操作操作，比如尝试构造样例对比java和c的程序；以及尝试用jit对java代码作不同层次的优化比较。



* 整体报告思路很清晰，从问题的提出到问题的实践的切入点都很好。只是感觉PGO优化这一块若能加上一些对实验结果的分析会好一点。